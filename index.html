<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>

    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>SurfStat</title>
  </head>
  <body>
    <a href="figs/subject100.jpg"><img src="figs/tn_tn_subject100.jpg"
        alt="[Click to enlarge image]" border="0" align="left"></a>
    <p>
      <a href="figs/vbmp.jpg"><img src="figs/tn_tn_vbmp.jpg" alt="[Click
          to enlarge image]" border="0" align="right"></a></p>
    <p>
    </p>
    <center>
      <h1>SurfStat 2<br>
      </h1>
      <h2>A Matlab toolbox for the statistical analysis of univariate
        and multivariate surface and volumetric data using linear mixed
        effects models and random field theory</h2>
      <b><a href="http://www.math.mcgill.ca/keith">Keith J. Worsley</a></b><br>
      <br>
      <p style="color:red;">Due to health reasons, please direct all
        enquiries to <a href="mailto:Carbonell@math.mcgill.ca">Felix
          Carbonell</a>.</p>
      <a href="surfstat.zip">Download it here!</a><br>
      <br>
      <em>Updated 21 February, 2009</em>
    </center>
    <br>
    SurfStat is a Matlab toolbox for the statistical analysis of
    univariate and multivariate surface and volumetric data using linear
    mixed effects models and random field theory. It is inspired by
    Jason Lerch's
    <a
      href="http://wiki.bic.mni.mcgill.ca/index.php/ThicknessStatistics">Thickness
      Statistics</a> written in <a
      href="http://en.wikipedia.org/wiki/R_%28 programming_language%29">R</a>,
    and Jonathan Taylor's BrainStat, part of <a
      href="http://neuroimaging.scipy.org/">NIPY</a>, written in <a
      href="http://www.python.org/Python">Python</a>.
    It is intended for cortical thickness data on triangular meshes,
    either for the whole cortex or one for each hemisphere. It will
    handle any triangulated surface data, written in <a
      href="http://surfer.nmr.mgh.harvard.edu/FreeSurfer">FreeSurfer</a><a>
      or </a><a
      href="http://wiki.bic.mni.mcgill.ca/index.php/ObjectFiles">MNI
      object</a> format.
    The only requirement is that the triangulation scheme must be the
    same for all surfaces, i.e. the data must be registered to a common
    surface.
    <p>
      <b>Reference:</b>
    </p>
    <li>Worsley, K.J., Taylor, J.E., Carbonell, F., Chung, M.K.,
      Duerden, E., Bernhardt, B., Lyttelton, O., Boucher, M., Evans,
      A.C. (2009). <a href="surfstat/poster.htm">SurfStat: A Matlab
        toolbox for the statistical analysis of univariate and
        multivariate surface and volumetric data using linear mixed
        effects models and random field theory.</a> <i>NeuroImage</i>,
      OHBM poster, accepted.
      <p>
      </p>
      <hr>
      <h3>New features in the latest version</h3>
    </li>
    <li>SurfStat now does statistical analysis for volumetric data, e.g.
      <a href="#vbm">VBM</a>, <a href="#dbm">DBM</a> and <a
        href="#pet">PET</a> data.
    </li>
    <li>New viewers added for volumetric data.
    </li>
    <li><a href="#map">Memory mapping</a> has been added to cope with
      very large data sets. There is now essentially
      no limit on the size of the data, but you will need some free disk
      space, equal to twice the size of the data, for scratch space.
      <hr>
      <h3>Features of the previous version</h3>
      Its main engine fits fixed effects and mixed effects, univariate
      and multivariate, linear models
      and makes inference using T, F, <a
        href="http://en.wikipedia.org/wiki/Hotelling%27s_T-square_distribution">Hotelling's
        T<sup>2</sup></a> and <a
href="http://mrw.interscience.wiley.com/emrw/9780470011812/eob/article/b2a10081/current/abstract">Roy's
        maximum root</a> statistics. Features:
      <p>
      </p>
    </li>
    <li> Random field theory (RFT) for peaks and clusters, as well as
      False Discovery Rate (FDR).
    </li>
    <li> Model formula rather than a design matrix for specifying the
      linear model.
    </li>
    <li> Mixed effects models fitted by <a
        href="http://en.wikipedia.org/wiki/Reml">ReML</a>.
    </li>
    <li> Off-the-shelf Matlab graphics that are ready to publish.
    </li>
    <li> FAST! everything loaded into memory.
    </li>
    <li> Truly interactive analysis, no need for batch.
    </li>
    <li> A mere 200K of code ...
      <p>
        Thanks to <a href="http://www.bic.mni.mcgill.ca/users/oliver/">Oliver
          Lyttelton</a> for suggesting the multivariate statistics, <a
          href="http://www.biostat.wisc.edu/People/faculty/chung.htm">Moo
          Chung</a> and <a
href="http://www.psych.nyu.edu/phelpslab/new/people/catherine_hartley.htm">Cate
          Hartley</a> for help with FreeSurfer, <a
          href="http://www.bic.mni.mcgill.ca/~boris/">Boris Bernhardt</a>
        for helping with the mixed effects, and <a
href="http://www2.bic.mni.mcgill.ca/research/people/alumni/profile_emmdue000">Emma
          Duerden</a> for constant feedback that has really improved the
        package.</p>
      <p>
      </p>
      <hr>
      <h3>User applications</h3>
    </li>
    <li><a href="http://www.biostat.wisc.edu/People/faculty/chung.htm">Moo
        Chung</a> has used SurfStat for <a
        href="http://www.stat.wisc.edu/~mchung/research/amygdala/">Amygdala
        Surface Modeling</a> (see the last section).
    </li>
    <li><a href="http://www.bic.mni.mcgill.ca/~boris/">Boris Bernhardt</a>
      has used SurfStat for cortical thickness in temporal lobe epilepsy
      (see the end of his web page).
      <hr>
      <h3>Contents</h3>
    </li>
    <li><a href="#install">Installation</a>
    </li>
    <li><a href="#help">Documentation and help</a>
    </li>
    <li><a href="#view">Viewing the data</a>
    </li>
    <li><a href="#readsurf">Reading the surface data</a>
    </li>
    <li><a href="#readthick">Reading the cortical thickness data</a>
    </li>
    <li><a href="#PCA">Principal Components Analysis</a>
    </li>
    <li><a href="#model">Model Formula</a>
    </li>
    <li><a href="#ICBMagain">Fitting the model</a>
    </li>
    <li><a href="#m-f">Main effect for gender</a>
    </li>
    <li><a href="#age">Main effect for age</a>
    </li>
    <li><a href="#interaction">Interaction</a>
    </li>
    <li><a href="#F">F statistics</a>
    </li>
    <li><a href="#connectivity">Connectivity</a>
    </li>
    <li><a href="#roi">ROI analysis</a>
    </li>
    <li><a href="#v2s">Volume to surface and vice-versa</a>
    </li>
    <li><a href="#mixed">Mixed effects, a.k.a. longitudinal data, a.k.a.
        repeated measures</a>
    </li>
    <li><a href="#map">Memory mapping</a>
    </li>
    <li><a href="#smooth">Smoothing</a>
    </li>
    <li><a href="#multi">Multivariate data statistical analysis</a>
    </li>
    <li><a href="#vbm">VBM data</a>
    </li>
    <li><a href="#dbm">DBM data</a>
    </li>
    <li><a href="#pet">PET data</a>
    </li>
    <li><a href="#pet2">PET data: more elaborate linear models</a>
    </li>
    <li><a href="#future">Future features</a>
    </li>
    <li><a href="#references">References for random field theory</a>
      <hr>
      <a name="install"></a>
      <h3>Installation</h3>
    </li>
    <li> Unzip the contents of <a href="surfstat.zip">surfstat.zip</a>
      into a directory
      called e.g. <code>C:\Program
        Files\MATLAB\R2006a\toolbox\local/surfstat/</code>.
    </li>
    <li> Go to the Matlab window and click <b>File --&gt; Set Path...
        ---&gt; Add Folder ... ---&gt;</b> <code>C:\Program
        Files\MATLAB\R2006a\toolbox\local/surfstat/</code> <b>--&gt; OK
        --&gt; Save</b>.
      <hr>
      <a name="help"></a>
      <h3>Documentation and help</h3>
      Here is <a href="doc/SurfStat/index.html">documentation</a><a>
        for all the functions in SurfStat,
        thanks to </a><a href="http://www.artefact.tk/">Guillaume
        Flandin</a>'s <a
        href="http://www.artefact.tk/software/matlab/m2html/">m2html</a>.
      If you want your own copy of this documentation, download it <a
        href="doc.zip">here</a>, unzip the file, and point your web
      browser to the <code>doc/SurfStat</code> directory.
      <p>
        You can get complete on-line documentation
        about any Matlab function, including the ones in SurfStat,
        by typing <code>help</code> followed by the
        name of the function, e.g.
      </p>
      <xmp>
help colormap
help SurfStatReadSurf
help term
</xmp>or you can <a href="http://www.math.mcgill.ca/keith">email</a> me
      - I love to get feed-back!
      <hr>
      <a name="view"></a>
      <h3>Viewing the data</h3>
      There is a FreeSurfer example at the end of this section, but
      throughout the rest of the web page, we shall analyse 147 subjects
      from the ICBM data base. The data is stored in <a
        href="http://wiki.bic.mni.mcgill.ca/index.php/ObjectFiles">MNI
        object</a> files. The scientific questions are not very
      exciting, but I have chosen them just to illustrate the ideas:
    </li>
    <li><a href="#m-f"> Is cortical thickness related to gender?</a>
    </li>
    <li><a href="#age"> Is cortical thickness related to age?</a>
    </li>
    <li><a href="#interaction"> Does the age effect depend on gender?</a>
    </li>
    <li><a href="#connectivity"> Does cortical thickness show any
        "functional" connectivity, and does the connectivity depend on
        age or gender?</a>
      <p>
        First let's read in one subject whose id is 100:
      </p>
      <xmp>
s100 = SurfStatReadSurf( {...
    'c:/keith/fMRI/ICBM/surfaces/mni_icbm_00100_mid_surface_left_81920.obj',...
    'c:/keith/fMRI/ICBM/surfaces/mni_icbm_00100_mid_surface_right_81920.obj'} );
t100 = SurfStatReadData( {...
    'c:/keith/fMRI/ICBM/thickness/mni_icbm_00100_native_rms_rsl_tlink_20mm_left.txt',...
    'c:/keith/fMRI/ICBM/thickness/mni_icbm_00100_native_rms_rsl_tlink_20mm_right.txt'} );
</xmp>The first thing you will want to do is to look at the data:
      <xmp>
SurfStatView( t100, s100, 'Cort Thick (mm), Subj 00100' );
</xmp><a name="s100"></a>
      <a href="figs/subject100.jpg"><img src="figs/tn_subject100.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        and perhaps save this as a .jpg file for publication or
        PowerPoint:
      </p>
      <xmp>
saveas( gcf, 'c:/keith/surfstat/figs/subject100.jpg' )
</xmp>You can make the lettering smaller by increasing
      the paper size before saving (maybe there is an easier way!).
      I have set it to 6 × 4.5, but to make the lettering smaller, try
      the Matlab default of 8 × 6:
      <xmp>
set(gcf,'PaperPosition',[0.25 2.5 8 6])
saveas( gcf, 'c:/keith/surfstat/figs/subject100.jpg' )
</xmp>You can play with figures quite a bit using the tool bar in the
      Matlab
      figure window. For example, you can click the "Rotate 3D" button,
      then
      rotate the images separately, or you can click the "Zoom In"
      button. The
      "Data Cursor" button allows you to click on a point and pull off
      the
      x,y,z coordinates, the index number (id) of the point, and its
      value.
      <p>
        <a href="figs/subject100rotate.jpg"><img
            src="figs/tn_subject100rotate.jpg" alt="[Click to enlarge
            image]" border="0"></a></p>
      <p>
        The point is marked by the little black and white square in the
        top centre figure.
        Its id is 66180, so you can type
      </p>
      <xmp>
&gt;&gt; t100(66180)
    2.5400
</xmp>to get the value, or to get the x,y,z coordinates:
      <xmp>
&gt;&gt; s100.coord(:,66180)
   31.6937
  -49.7099
   74.2872
</xmp>Some people prefer a black background:
      <xmp>
SurfStatView( t100, s100, 'Cort Thick (mm), Subj 00100', 'black' );
</xmp>If you are unhappy with the colour map, then try one of the Matlab
      alternatives:
      <xmp>
SurfStatColormap( 'jet' );
</xmp>A common adjustment is the limits on the colour bar, for which
      there is
      a special function:
      <xmp>
SurfStatColLim( [3 4] );
</xmp><a href="figs/subject100black.jpg"><img
          src="figs/tn_subject100black.jpg" alt="[Click to enlarge
          image]" border="0"></a>
      <p>
        For further customizing, see the code of the <code>SurfStatViewData.m</code>
        function.</p>
      <p>
        You may just want to work with one hemisphere:
      </p>
      <xmp>
s100left = SurfStatReadSurf( ...
    'c:/keith/fMRI/ICBM/surfaces/mni_icbm_00100_mid_surface_left_81920.obj');
t100left = SurfStatReadData( ...
    'c:/keith/fMRI/ICBM/thickness/mni_icbm_00100_native_rms_rsl_tlink_20mm_left.txt' );
SurfStatView( t100left, s100left, 'Cort Thick (mm), Subj 00100' );
</xmp><a href="figs/subject100left.jpg"><img
          src="figs/tn_subject100left.jpg" alt="[Click to enlarge
          image]" border="0"></a>
      <p>
        Finally a FreeSurfer example, courtesy <a
          href="http://www.biostat.wisc.edu/People/faculty/chung.htm">Moo
          Chung</a>:
      </p>
      <xmp>
s = SurfStatReadSurf( {...
    'c:/keith/surfstat/FreeSurferdata/lh.pial', ...
    'c:/keith/surfstat/FreeSurferdata/rh.pial'} );
t = SurfStatReadData( {...
    'c:/keith/surfstat/FreeSurferdata/lh.thickness', ...
    'c:/keith/surfstat/FreeSurferdata/rh.thickness'} );
SurfStatView( t, s, 'Cort Thick (mm), FreeSurfer data' );
</xmp><a href="figs/FS.jpg"><img src="figs/tn_FS.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        You can check that the FreeSurfer surface has no topological
        deformities by calculating its Euler characteristic (EC):
      </p>
      <xmp>
SurfStatResels(s)
     4
</xmp>The answer is 4, which is what you would get for a pair of
      spherical surfaces. However there are other non-spherical surfaces
      with the same EC, so you can only say that if the EC were <i>not</i>
      4, then it would <i>not</i> be a pair of spherical surfaces.
      <hr>
      <a name="readsurf"></a>
      <h3>Reading the surface data</h3>
      First you have to make a list of all the names of the files. I
      have
      excluded 5 of the 152 subjects because their data was bad or
      incomplete,
      and written <code>SurfStatListDir.m</code> to list the contents
      of a directory:
      <xmp>
excludefiles = [ '00220'; '00338'; '00111'; '00128'; '00137' ];
filesleft  = SurfStatListDir( 'c:/keith/fMRI/ICBM/surfaces/mni_icbm_00*_mid_surface_left_81920.obj', excludefiles );
filesright = SurfStatListDir( 'c:/keith/fMRI/ICBM/surfaces/mni_icbm_00*_mid_surface_right_81920.obj', excludefiles );
filesboth = [ filesleft, filesright ];
</xmp>The only reason you need all the surfaces is to find the average
      surface:
      <xmp>
avsurf = SurfStatAvSurf( filesboth );
SurfStatWriteSurf( 'c:/keith/fmri/icbm/av.obj', avsurf );
</xmp>This takes 2 minutes on my 2-year-old laptop, so instead we shall
      read it
      in directly:
      <xmp>
avsurf = SurfStatReadSurf( 'c:/keith/fmri/icbm/av.obj' );
</xmp>Now we need a mask to exclude the inter-hemispheric cut:
      <xmp>
mask = SurfStatMaskCut( avsurf );
SurfStatView( mask, avsurf, 'Masked average surface' );
</xmp><a href="figs/avsurf.jpg"><img src="figs/tn_avsurf.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        You might want to also exclude the brain stem. To do this, I
        clicked on where I thought the centre of the brain stem was: (0;
        -16; -8)mm, and I clicked a bit further out to guess the radius:
        20mm. Then you can add a ball-shaped ROI to the mask as follows
        (see <a href="#roi">ROI</a>):
      </p>
      <xmp>
mask = mask &amp; SurfStatROI( [0; -16; -8], 20, avsurf ) == 0;
SurfStatView( maskb, avsurf, 'Masked average surface -brainstem' );
</xmp><a href="figs/avsurfb.jpg"><img src="figs/tn_avsurfb.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Since I don't really know where the brain stem is, I shall just
        stick to the first mask in what follows.
      </p>
      <hr>
      <a name="readthick"></a>
      <h3>Reading the cortical thickness data</h3>
      Let's suppose the file names and covariates are in a file similar
      to what
      we use for <a
href="http://wiki.bic.mni.mcgill.ca/index.php/VoxelBasedMorphometryOptimized"><code>glim_image</code></a>,
      i.e. a text file with fields for the thickness
      file names, and the covariates:
      <xmp>
sub_1_left.txt  subj_1_right.txt   female  19.6906
sub_2_left.txt  subj_2_right.txt   female  24.8378
sub_3_left.txt  subj_3_right.txt   male    29.8617
sub_4_left.txt  subj_4_right.txt   male    22.7214
sub_5_left.txt  subj_5_right.txt   male    34.8118
...
</xmp>This can be read by the standard Matlab <code>textread</code>:
      <xmp>
[thickfileleft, thickfileright, gender, age] ...
    = textread( 'c:/keith/fMRI/ICBM/glim.txt', '%s %s %s %f' );
clf; hist( age ); xlabel('age');
</xmp><a href="figs/histage.jpg"><img src="figs/tn_histage.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        To read in the actual thickness data from the above files:
      </p>
      <xmp>
Y=SurfStatReadData( [thickfileleft, thickfileright] );
</xmp>To save memory, this is stored as single precision (4 bytes),
      but all subsequent calculations (except <a href="#smooth">smoothing</a>)
      are done
      in double precision (8 bytes).
      <p>
        Let's take a look at the mean thickness for vertices:
        <a name="FigmeanY"></a>
      </p>
      <xmp>
meanthick = mean( double( Y ) );
SurfStatView( meanthick, avsurf, 'Mean thickness (mm), n=147' );
</xmp><a href="figs/meanthick.jpg"><img src="figs/tn_meanthick.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        We can save this for later:
      </p>
      <xmp>
save c:/keith/surfstat/data/meanthick meanthick
</xmp>Let's take a look at the mean thickness for subjects:
      <xmp>
meanthicksubj = mean( double( Y(:, mask) ), 2 );
SurfStatPlot( age, meanthicksubj );
</xmp><a href="figs/meanthicksubjage.jpg"><img
          src="figs/tn_meanthicksubjage.jpg" alt="[Click to enlarge
          image]" border="0"></a>
      <p>
        As expected, thickness decreases with age. The line looks a bit
        faint, and the markers are too small. You can change the
        line width and marker size as follows:
      </p>
      <xmp>
SurfStatPlot( age, meanthicksubj, [], [], 'LineWidth',2, 'MarkerSize',12 );
</xmp><a href="figs/meanthicksubjage2.jpg"><img
          src="figs/tn_meanthicksubjage2.jpg" alt="[Click to enlarge
          image]" border="0"></a>
      <p>
        or you can edit the figure by clicking on the "Edit Plot" button
        (the one with the little arrow) in the Figure toolbar, then
        double-clicking on the feature you want to edit.</p>
      <p> For gender:
      </p>
      <xmp>
SurfStatPlot( gender, meanthicksubj );
</xmp><a href="figs/meanthicksubjgender.jpg"><img
          src="figs/tn_meanthicksubjgender.jpg" alt="[Click to enlarge
          image]" border="0"></a>
      <p>
        Males appear to have overall thicker cortex than females.</p>
      <p>
        FreeSurfer group registered data is often stored in two <code>.mgh</code>
        files. In the following example, data on 18 subjects is in two
        files. To read these in:
      </p>
      <xmp>
Y = SurfStatReadData( { 'c:/keith/surfstat/FS/mgh/lh.thickness.mgh',...
    'c:/keith/surfstat/FS/mgh/rh.thickness.mgh' } );
</xmp><code>Y</code> is an 18 × 327684 matrix of cortical thickness data
      on the 18 subjects. To read in one of the surfaces:
      <xmp>
s = SurfStatReadSurf( { 'c:/keith/surfstat/FS/mgh/lh.pial',...
    'c:/keith/surfstat/FS/mgh/rh.pial' } );
</xmp>and view the average thickness:
      <xmp>
SurfStatView( mean( Y ), s, 'Mean of 18 registered FS thicknesses');
</xmp>
      <hr>
      <a name="PCA"></a>
      <h3>Principal Components Analysis</h3>
      Principal Components Analysis is a useful exploratory tool for
      checking the data or discovering connectivity.
      <xmp>
[ pcntvar, U, V ] = SurfStatPCA( Y, mask );
pcntvar
   33.5008    4.0641    3.3371    2.3098
</xmp>The first component is by far the largest, explaining 33.5% of the
      variability of the data.
      <xmp>
SurfStatView( V(1,:), avsurf, 'First Principal Component, 33.5% variance' );
</xmp><a href="figs/PCAV1.jpg"><img src="figs/tn_PCAV1.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        It looks as if this is a "whole brain" component,
        i.e. the thickness on the entire surface is positively
        correlated.
        An explanation is that some subjects have overall thick cortex,
        some
        have overall thin cortex, perhaps due to differences in contrast
        at
        the grey-white boundary. See <code>SurfStatNorm.m</code> to
        normalize the
        cortical surface data, either by subtracting or dividing the
        global mean. However before doing this, let's plot the
        subject component against age:
      </p>
      <xmp>
SurfStatPlot( age, U(:,1) ); title('First Principal Component, 33.5% variance');
</xmp><a href="figs/PCAU1.jpg"><img src="figs/tn_PCAU1.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        The global effect decreases with age; in other words, it could
        be just an age-related atrophy effect. This makes sense: since
        the spatial component is
        roughly constant across the brain, then the subject component
        must be the global average, which we have already <a
          href="#readthick">noted</a> decreases with age.</p>
      <p>
        Now let's look at the second component,
        which explains a mere 4.1% of the variability:
      </p>
      <xmp>
SurfStatView( V(2,:), avsurf, 'Second Principal Component, 4.1% variance' );
</xmp><a href="figs/PCAV2.jpg"><img src="figs/tn_PCAV2.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        Plotting the subject component against gender:
      </p>
      <xmp>
SurfStatPlot( gender, U(:,2) ); title('Second Principal Component, 4.1% variance');
</xmp><a href="figs/PCAU2.jpg"><img src="figs/tn_PCAU2.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        We note that the second component might be a gender effect.
        Females score positively on this component, so they have higher
        cortical thickness in the red areas, lower cortical thickness in
        the blue areas, compared to males.</p>
      <p> Higher order components seem to be more difficult to
        interpret.
      </p>
      <hr>
      <a name="model"></a>
      <h3>Model Formula</h3>
      This is the fun bit: specifying the model by a model formula,
      rather than
      a design matrix. Model formulas were pioneered by
      <a href="http://en.wikipedia.org/wiki/GenStat">GenStat</a> and
      <a href="http://en.wikipedia.org/wiki/GLIM_%28software%29"> GLIM</a>
      in the early 1970's, and are now used in most statistics packages
      such as
      <a href="http://en.wikipedia.org/wiki/R_%28
        programming_language%29">R</a> and
      <a href="http://en.wikipedia.org/wiki/SAS_System">SAS</a>. To show
      you the idea, let's cut it down to the first 5 subjects:
      <xmp>
&gt;&gt; age5 = age(1:5)
   19.6906
   24.8378
   29.8617
   22.7214
   34.8118
&gt;&gt; gender5 = gender(1:5)
    'female'
    'female'
    'male'
    'male'
    'male'
</xmp>The idea is to convert variables into a newly defined Matlab class
      called a <code>term</code>. For the
      technically minded, a <code>term</code> has two components: a
      matrix, and a cell of strings
      for the names of the columns. The function <code>term.m</code>
      converts a vector or a
      cell array of strings to a <code>term</code>, which is displayed
      as follows:
      <xmp>
&gt;&gt; Age = term( age5 )

  age5
---------
  19.6906
  24.8378
  29.8617
  22.7214
  34.8118

&gt;&gt; Gender = term( gender5 )

  female  male
--------------
  1       0
  1       0
  0       1
  0       1
  0       1
</xmp><code>double</code> and <code>char</code> convert
      a <code>term</code> back to its matrix and name components.
      The operators <code>+</code>, <code>*</code>, <code>^</code>
      and <code>-</code> have been redefined (overloaded) for <code>term</code>s
      so that they match the operation of terms in a model formula.
      You now write down a model formula (without the coefficients)
      e.g. a main effect of Age and Gender:
      <xmp>
&gt;&gt; 1 + Age + Gender

  1  age5     female  male
--------------------------
  1  19.6906  1       0
  1  24.8378  1       0
  1  29.8617  0       1
  1  22.7214  0       1
  1  34.8118  0       1
</xmp>Perhaps you suspect that the age effect depends on gender, i.e.
      you want
      to add an interaction between Age and Gender;
      <xmp>
&gt;&gt; 1 + Age + Gender + Age*Gender

  1  age5     female  male  age5*female  age5*male
---------------------------------------------------------
  1  19.6906  1       0     19.6906            0
  1  24.8378  1       0     24.8378            0
  1  29.8617  0       1           0      29.8617
  1  22.7214  0       1           0      22.7214
  1  34.8118  0       1           0      34.8118
</xmp>This could also be written as
      <xmp>
&gt;&gt; (1 + Age)*(1 + Gender)

  1  age5     female  age5*female  male  age5*male
---------------------------------------------------------
  1  19.6906  1       19.6906      0           0
  1  24.8378  1       24.8378      0           0
  1  29.8617  0             0      1     29.8617
  1  22.7214  0             0      1     22.7214
  1  34.8118  0             0      1     34.8118
</xmp>Perhaps a quadratic effect of Age?
      <xmp>
&gt;&gt; 1 + Age + Age^2

  1  age5     age5*age5
------------------------------
  1  19.6906  387.71973
  1  24.8378  616.91631
  1  29.8617  891.72113
  1  22.7214  516.26202
  1  34.8118  1211.8614
</xmp>or a cubic Age effect?
      <xmp>
&gt;&gt; (1 + Age)^3

  1  age5     age5*age5  age5*age5*age5
----------------------------------------------
  1  19.6906  387.71973  7634.43408
  1  24.8378  616.91631  15322.8439
  1  29.8617  891.72113  26628.3088
  1  22.7214  516.26202  11730.1958
  1  34.8118  1211.8614  42187.0774
</xmp>Maybe you don't want a term, such as the constant term
      <xmp>
&gt;&gt; (1 + Age)^3 - 1

  age5     age5*age5  age5*age5*age5
------------------------------------
  19.6906  387.71973  7634.43408
  24.8378  616.91631  15322.8439
  29.8617  891.72113  26628.3088
  22.7214  516.26202  11730.1958
  34.8118  1211.8614  42187.0774
</xmp>
      <hr>
      <a name="ICBMagain"></a>
      <h3>Fitting the linear model</h3>
      Back to the full data, let's specify a main effect of age and
      gender:
      <xmp>
Age = term( age );
Gender = term( gender );
M = 1 + Age + Gender

  1  age      female  male
---------------------------------
  1  19.6906  1       0
  1  24.8378  1       0
  1  29.8617  0       1
  1  22.7214  0       1
  1  34.8118  0       1
...
</xmp>You can see this as an SPM-style image:
      <xmp>
image( M );
</xmp><a href="figs/X.jpg"><img src="figs/tn_X.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        (The empty space on the right is reserved for the design matrix
        for the
        variance of a <a href="#mixed">mixed effects model</a>.)
        Now let's fit the linear model, saving the results in <code>slm</code>:
      </p>
      <xmp>
slm = SurfStatLinMod( Y, M, avsurf );
</xmp>In case you are interested, you can see what's in <code>slm</code>
      by typing
      <xmp>
&gt;&gt; slm
       X: [147x4 double]
      df: 144
    coef: [4x81924 double]
     SSE: [1x81924 double]
     tri: [163840x3 int32]
    resl: [245760x1 double]
</xmp><code>slm.X</code> is the design matrix,
      <code>slm.df</code> is the error degrees of freedom, <code>slm.coef</code>
      is the coefficients, <code>slm.SSE</code> is
      error sum of squares, <code>slm.tri</code> is the list of
      triangle indices and <code>slm.resl</code> is a function of the
      resels along each edge.
      Normally you never need to look at any of these things!
      <hr>
      <a name="m-f"></a>
      <h3>Main effect for gender</h3>
      Let's look at the T statistic for male-female. To set up the
      contrast,
      we specify it in terms of the <i>observations</i> rather than in
      terms of the coefficients (see <code>help SurfStatT</code> for
      more information on this):
      <xmp>
contrast = Gender.male - Gender.female
    -1
    -1
     1
     1
     1
...
</xmp><code>contrast</code> is a numeric 147 × 1 vector. Note how <code>Gender.male</code>
      gives you the numeric indicator variable for
      <code>male</code>, i.e. 1 if the observation is <code>male</code>,
      and 0 otherwise. Then to get the T statistic:
      <xmp>
slm = SurfStatT( slm, contrast )

       X: [147x4 double]
      df: 144
    coef: [4x81924 double]
     SSE: [1x81924 double]
     tri: [163840x3 int32]
    resl: [245760x1 double]
       c: [7.9797e-017 1.3010e-018 -1.0000 1.0000]
       k: 1
      ef: [1x81924 double]
      sd: [1x81924 double]
       t: [1x81924 double]
</xmp>The contrast in the columns of the design matrix <i>X</i> is in <code>slm.c</code>.
      It equals [0 0 -1 1] (to machine accuracy), i.e. column 4 - column
      3. <code>slm.k</code> is the number of variates (univariate in
      this case). Effects are in <code>slm.ef</code>, and their
      standard deviations (standard
      errors) are in <code>slm.sd</code>.
      The T statistic is in <code>slm.t</code>, and by multiplying it
      by <code>mask</code>, we set
      all the values outside the mask to zero, which makes it better
      to look at:
      <xmp>
SurfStatView( slm.t.*mask, avsurf, 'T (144 df) for males-females removing age' );
</xmp><a href="figs/Tm-f.jpg"><img src="figs/tn_Tm-f.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        To find the threshold for P=0.05, corrected, the resels are:
        <a name="thresh"></a>
      </p>
      <xmp>
resels = SurfStatResels( slm, mask )
    2.0000   19.6153  578.5045
stat_threshold( resels, sum(mask), 1, slm.df )
    4.4259
</xmp>However the best way is to view the P-values for each vertex.
      <xmp>
[ pval, peak, clus ] = SurfStatP( slm, mask );
</xmp><code>pval.P</code> contains P-values for peaks, and
      <code>pval.C</code> contains P-values for clusters.
      This special structure is recognised by <code>SurfStatView</code>
      which draws the figure in a special way:
      <xmp>
SurfStatView( pval, avsurf, 'Males-females removing age' );
</xmp><a href="figs/Pm-f.jpg"><img src="figs/tn_Pm-f.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Maybe there is something hidden; try inflating the average
        brain:
      </p>
      <xmp>
avsurfinfl = SurfStatInflate( avsurf );
SurfStatView( pval, avsurfinfl, 'Males-females removing age' );
</xmp><a href="figs/Pm-finfl.jpg"><img src="figs/tn_Pm-finfl.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        If you want to inflate it more, try
      </p>
      <xmp>
avsurfinfl = SurfStatInflate( avsurf, 0.75 );
</xmp><code>peak</code> and <code>clus</code>
      contain a list of peaks and clusters, together with their
      P-values, as in <a
        href="http://www.math.mcgill.ca/keith/fmristat/">
        FmriStat</a>. They can be displayed nicely by converting them to
      a <code>term</code>:
      <xmp>
&gt;&gt; term( clus )
  clusid  nverts  resels     P
----------------------------------------
   1       710       8.7714  2.5675e-007
   2      1460       6.4006  2.5699e-007
   3       546       5.6912  2.5865e-007
 ...
  12       187      0.95521     0.033553
  13        37      0.93294     0.036895
  14       102      0.81846     0.060139
  15       161      0.53477      0.19819
...
</xmp>There are 13 clusters whose extent is significant at P=0.05.
      The peaks are:
      <xmp>
&gt;&gt; term( peak )
  t       vertid  clusid  P
------------------------------------
  5.7658  70593    1       0.0002103
  5.7541  70586    1      0.00022173
  5.7433  70557    1      0.00023325
...
  4.4435  29130    2        0.046866
  4.4326  75010    4        0.048814
   4.419  39444    5        0.051243
  4.4067  39760    3        0.053529
...
</xmp>Where is the largest peak with id=70593? Here are the x,y,z
      coordinates in mm
      on the average surface:
      <xmp>
&gt;&gt; avsurf.coord(:,70593)
    5.9320
  -23.6405
   29.8528
</xmp>If you want all the coordinates in mm added to the table, try
      this:
      <xmp>
&gt;&gt; term( peak ) + term( SurfStatInd2Coord( peak.vertid, avsurf )', {'x','y','z'})
  t       vertid  clusid  P           x         y          z
--------------------------------------------------------------------
  5.7658  70593    1       0.0002103   5.93198   -23.6405    29.8528
  5.7541  70586    1      0.00022173   5.52406   -19.2547    30.3012
  5.7433  70557    1      0.00023325   4.73798   -12.3197    30.9665
...
  4.4435  29130    2        0.046866  -1.34981   -8.22836    27.8238
  4.4326  75010    4        0.048814   30.8152   -77.5804    25.1885
   4.419  39444    5        0.051243  -16.2635   -82.7056   -12.8587
  4.4067  39760    3         0.05353  -20.5747   -36.3622    1.15415
...
</xmp>How does the data look at the largest peak? Here's a plot against
      gender, adjusting for age:
      <xmp>
SurfStatPlot( gender, Y( :, 70593 ), age );
</xmp><a href="figs/Yga.jpg"><img src="figs/tn_Yga.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Note that the the F statistic on the plot is the square of the
        maximum T statistic for the contrast, i.e. 33.24 = 5.7658^2. F
        statistics with one degree of freedom always equal the square of
        T statistics. Moreover the P-values are also the same, i.e. the
        P-value of the F is the P-value of the 2-sided T (equal to twice
        the P-value of the one-sided T).</p>
      <p>
        Finally, Q values or False Discovery Rate:
      </p>
      <xmp>
qval = SurfStatQ( slm, mask );
SurfStatView( qval, avsurf, 'Males-females removing age' );
</xmp><a href="figs/Qm-f.jpg"><img src="figs/tn_Qm-f.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Recall that:
      </p>
    </li>
    <li> RFT controls the probability of <i>ever</i> finding a false
      positive - you will <i>never</i> report a false positive, 19
      times out of 20.
    </li>
    <li> FDR controls the <i>proportion</i> of false positives amongst
      your discoveries - you will <i>always</i> report false positives,
      but not too many (1/20).
      <p>
      </p>
    </li>
    <li> RFT is useful for <i>confirmation</i> (e.g. scientific
      publication) - you want to be sure that <i>all</i> your
      discoveries are real.
    </li>
    <li> FDR is useful for <i>exploration</i> (e.g. drug discovery:
      costs are in $$$) - you want to make discoveries, but not too many
      bad ones.
      <hr>
      <a name="age"></a>
      <h3>Main effect for age</h3>
      Now try T statistics for a negative effect of age on cortical
      thickness:
      <xmp>
slm = SurfStatT( slm, -age );
SurfStatView( slm.t.*mask, avsurf, 'T (144 df) for -age removing gender' );
</xmp><a name="T"></a>
      <a href="figs/Tage.jpg"><img src="figs/tn_Tage.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Let's try to click on the maximum T statistic with the "Data
        Cursor" button. I can't hit it exactly - the cursor is
        just to the right of the mask in the middle right figure. To
        find the id try:
      </p>
      <xmp>
&gt;&gt; find( slm.t == max( slm.t ) )
      81887
</xmp>To plot the cortical thickness at this point against age,
      adjusting for gender:
      <xmp>
Yseed = double( Y(:,81887) );
SurfStatPlot( age, Yseed, gender );
</xmp><a href="figs/seedage.jpg"><img src="figs/tn_seedage.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        P and Q-values, in one line:
        <a name="FigP"></a>
      </p>
      <xmp>
SurfStatView( SurfStatP( slm, mask ), avsurf, '-Age removing gender' );
</xmp><a href="figs/Page.jpg"><img src="figs/tn_Page.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Only clusters are significant, and not peaks. This suggests that
        the age effect covers large regions, rather than local foci.
        This
        agrees with our conclusion above that there is age-related
        atrophy
        right across the brain. FDR tells the same story:
      </p>
      <xmp>
SurfStatView( SurfStatQ( slm, mask ), avsurf, '-Age removing gender' );
</xmp><a href="figs/Qage.jpg"><img src="figs/tn_Qage.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
      </p>
      <hr>
      <a name="interaction"></a>
      <h3>Interaction</h3>
      Is the age effect the same for males and females?
      Test for an interaction between Age and Gender:
      <xmp>
slm = SurfStatLinMod( Y, 1 + Age + Gender + Age*Gender, avsurf );
slm = SurfStatT( slm, age.*Gender.male - age.*Gender.female );
SurfStatView( slm.t.*mask, avsurf, 'T (143 df) for age*(male-female)' );
</xmp><a href="figs/Tagem-f.jpg"><img src="figs/tn_Tagem-f.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Nothing doing here. Nevertheless, let's take a look at what is
        happening at the seed point. Here's a plot of <code>Yseed</code>
        against <code>age</code> with two separate lines for each <code>gender</code>:
      </p>
      <xmp>
SurfStatPlot( age, Yseed, 1, gender );
</xmp><a href="figs/seedagegen.jpg"><img src="figs/tn_seedagegen.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        As before, a negative effect of age (atrophy), but little
        difference in slope between the two genders.
      </p>
      <hr>
      <a name="F"></a>
      <h3>F statistics</h3>
      F statistics are obtained by comparing nested models.
      For example, let's compare the above model with interaction to the
      null model
      with just a constant, which can be fitted without bothering with
      the surface in the third argument:
      <xmp>
slm0 = SurfStatLinMod( Y, 1 );
slm = SurfStatF( slm, slm0 );
SurfStatView( slm.t.*mask, avsurf, 'F statistic, 3,143 df' );
</xmp>F statistics are in <code>slm.t</code>, and their degrees of
      freedom are in <code>slm.df</code>=[3 143].
      <p>
        <a href="figs/Fagemf.jpg"><img src="figs/tn_Fagemf.jpg"
            alt="[Click to enlarge image]" border="0"></a></p>
      <p>
        The P and Q values are calculated using the same functions. The
        software knows that <code>slm.t</code> is an F statistic,
        rather than a T statistic, because
        an F statistic has two degrees of freedom:
      </p>
      <xmp>
SurfStatView( SurfStatP( slm, mask ), avsurf, 'F statistic, 3,143 df' );
</xmp><a href="figs/Pagemf.jpg"><img src="figs/tn_Pagemf.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
      </p>
      <xmp>
SurfStatView( SurfStatQ( slm, mask ), avsurf, 'F statistic, 3,143 df' );
</xmp><a href="figs/Qagemf.jpg"><img src="figs/tn_Qagemf.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
      </p>
      <hr>
      <a name="connectivity"></a>
      <h3>Connectivity</h3>
      Let's take the seed as the peak of the age effect above. It is
      located
      just to the right of the mask in the middle right figure. Is
      the cortical thickness at this point correlated with the rest of
      the cortical surface, allowing for an effect of age and gender?
      <xmp>
slm = SurfStatLinMod( Y, 1 + Age + Gender + term(Yseed), avsurf );
slm = SurfStatT( slm, Yseed );
SurfStatView( slm.t.*mask, avsurf, 'Connectivity' );
SurfStatColLim( [0 5] );
</xmp>Of course the T statistic is infinite at the seed itself,
      so we needed to reset the colour limits:
      <p>
        <a href="figs/C.jpg"><img src="figs/tn_C.jpg" alt="[Click to
            enlarge image]" border="0"></a></p>
      <p>
        A large part of the brain is correlated with the seed. However
        I would claim that pure connectivity as above is of little
        scientific interest.
        A more interesting question is how the connectivity
        changes with say gender. To answer this, add an interaction
        between seed
        and the rest of the model, then look at the interaction between
        seed and gender:
      </p>
      <xmp>
slm = SurfStatLinMod( Y, ( 1 + Age + Gender )*( 1 + term(Yseed) ), avsurf );
slm = SurfStatT( slm, Yseed.*Gender.female - Yseed.*Gender.male );
SurfStatView( slm.t.*mask, avsurf, 'Female connectivity - male connectivity' );
</xmp><a href="figs/Cm-f.jpg"><img src="figs/tn_Cm-f.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        There is really no evidence for a gender effect on connectivity.
        Nevertheless, let's take a look at the most significant peak at
        <code>id=3698</code> tucked inside the left temproal lobe. The T
        statistic is <code>slm.t(3698)=3.7024</code>. To see how the
        connectivity differs between genders, here's a plot of the data
        <code>Y3698</code> at that point. The data is adjusted for <code>Age</code>
        and its interaction with <code>Yseed</code>, and plotted
        against <code>Yseed</code> for each gender:
      </p>
      <xmp>
Y3698 = Y( :, 3698 );
M = ( 1 + Age )*( 1 + term(Yseed) );
SurfStatPlot( Yseed, Y3698, M, gender);
</xmp><a href="figs/YseedC.jpg"><img src="figs/tn_YseedC.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        As you can see, the connectivity is more in females than males,
        which is why the T statistic was positive. The F statistic is <code>13.71=3.7024^2</code>
        as expected.</p>
      <p>
        How does the connectivity change with age?
      </p>
      <xmp>
slm = SurfStatT( slm, Yseed.*age );
SurfStatView( slm.t.*mask, avsurf, 'Age effect on connectivity' );
SurfStatColLim( [-5 5] );
</xmp>Again there were some spurious large values in the vicinity of the
      seed, so we had to reset the colour limits:
      <p>
        <a href="figs/Cage.jpg"><img src="figs/tn_Cage.jpg" alt="[Click
            to enlarge image]" border="0"></a></p>
      <p>
        This looks more promising; for confirmation:
      </p>
      <xmp>
SurfStatView( SurfStatP( slm, mask ), avsurf, 'Age effect on connectivity' );
</xmp><a href="figs/PCage.jpg"><img src="figs/tn_PCage.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        This time there is one small significant cluster where
        connectivity increases with age ... or maybe this is just the
        1 time out of 20 when we expect to see a false positive!</p>
      <p>
        Unfortunately there is no easy way to make a plot that show the
        effect of an interaction between two continuous variables (here
        <code>Yseed</code> and <code>age</code>).
      </p>
      <hr>
      <a name="roi"></a>
      <h3>ROI analysis</h3>
      If you have a surface atlas handy, you can read in a mask for an
      ROI just like thickness data, but taking the values 1 inside the
      ROI and 0 outside. If you have a volumetric atlas handy, see <a
        href="#v2s">below</a>. If you don't have an atlas handy, you can
      make a circular ROI centred at a point, as follows. You specify
      the centre either as <code>[x; y; z]</code> coordinates or by a
      vertex id. For example, one of our users was interested in a
      region in the top right figure. We clicked on the centre and found
      the <code>id</code>=53815. To make the ROI with a radius of 10mm:
      <xmp>
id = 53815;
maskROI = SurfStatROI( id, 10, avsurf );
</xmp><a href="figs/ROI.jpg"><img src="figs/tn_ROI.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        The region shows up as white in the top right figure, just
        behind the temporal lobe. </p>
      <p>
        You could also make an ROI from a cluster. Let's take the
        clusters of the T statistic for age in the model <code>M = Age
          + Gender</code>. The variable <code>clusid</code> contains
        the cluster id's for each vertex, obtained by adding a fourth
        output argument to <code>SurfStatP</code>:
      </p>
      <xmp>
slm = SurfStatT( SurfStatLinMod( Y, 1 + Age + Gender, avsurf ), -age );
[ pval, peak, clus, clusid ] = SurfStatP( slm, mask );
SurfStatView( pval, avsurf );
</xmp><a href="figs/ROIcluster.jpg"><img src="figs/tn_ROIcluster.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        (The Figure is the same as <a href="#FigP">before</a>.)
        Suppose we want to make an ROI from the dark blue cluster. First
        click on any point in the cluster, find its <code>id</code>=27805
        (its P-value is 0.016783), then
      </p>
      <xmp>
clusid( 27805 )
    10
</xmp>is its cluster id number (10). We can now make an ROI out of
      cluster 10:
      <xmp>
maskROI = clusid == clusid( 27805 );
</xmp>By adding a third argument to <code>SurfStatP</code> (see <code>help
        SurfStatP</code>) you can change the threshold for defining
      clusters to any arbitrary value; by default it is the uncorrected
      P=0.001 threshold.
      <p>
        You can find clusters for any (non-statistical) image using <code>SurfStatPeakClus</code>,
        as follows. Suppose we want to form an ROI from the mean
        thickness, as <a href="#FigmeanY">here</a>. First make a
        structure, say <code>s</code>, with two fields <code>t</code>
        containing the data, and <code>tri</code> containing the
        triangles (<code>s</code> is arbitrary, but you must use <code>t</code>
        and <code>tri</code> as fields):
      </p>
      <xmp>
s.t = mean(Y);
s.tri = avsurf.tri;
[ peak, clus, clusid ] = SurfStatPeakClus( s, mask, 4 );
SurfStatView( clusid, avsurf, 'Mean thickness (mm) &gt; 4' );
</xmp><a href="figs/ROImeanY.jpg"><img src="figs/tn_ROImeanY.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        The figure shows the cluster id's (by coincidence there are four
        clusters). To make an ROI out of the green cluster (<code>clusid</code>=2,
        read from the colour bar in the figure):
      </p>
      <xmp>
maskROI = clusid == 2;
</xmp>ROI's can be combined using the Matlab logical operations. Suppose
      you had two ROI's
      <code>maskROI1</code> and <code>maskROI2</code>.
      Using the Matlab "or" operator <code>|</code>, their union is
      <xmp>
maskROI = maskROI1 | maskROI2;
</xmp>To get their intersection, use the "and" operator <code>&amp;</code>.
      <p>
        Going back to the linear model with age and gender, we can
        find the resels of the first ROI:
      </p>
      <xmp>
slm = SurfStatLinMod( Y, 1 + Age + Gender, avsurf );
reselsROI = SurfStatResels( slm, maskROI )
    1.0000    5.7081    4.6337
</xmp>Note that the first component is 1, which is the Euler
      Characteristic, suggesting that
      our ROI is a single connected region and does not contain any
      fragments or holes.
      If we wanted to search for peaks within the ROI (not likely since
      it is so small!) we should use a T statistic P=0.05 threshold of
      3.0254:
      <xmp>
stat_threshold( reselsROI, sum(maskROI), 1, slm.df)
    3.0254
</xmp>Usually we want to average the data within the ROI and analyze
      that:
      <xmp>
YROI = mean( Y(:, maskROI), 2 );
</xmp>This will give you a vector of the average thickness inside the
      ROI.
      To plot it against age, adjusting for gender:
      <xmp>
SurfStatPlot( age, YROI, gender );
</xmp><a href="figs/ROIage.jpg"><img src="figs/tn_ROIage.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        <code>YROI</code> can be treated exactly like <code>Y</code>
        itself, but without specifying the surface, e.g.
      </p>
      <xmp>
slmROI = SurfStatLinMod( YROI, 1 + Age + Gender );
slmROI = SurfStatT( slmROI, -age )
       X: [147x4 double]
      df: 144
    coef: [4x1 double]
     SSE: 14.3026
      ef: 0.0159
      sd: 0.0054
       t: 2.9428
</xmp>Obviously FDR is irrelevant, but to get P-values
      use
      <xmp>
SurfStatP( slmROI )
    P: 0.0019
</xmp>You could also get F statistics in the usual way:
      <xmp>
slmROI = SurfStatF( slmROI, slm0ROI )
SurfStatP( slmROI )
</xmp>
      <hr>
      <a name="v2s"></a>
      <h3>Volume to surface and vice-versa</h3>
      Most brain imaging data, such as atlases, are volumetric, so we
      need a handy way to get volumetric data onto surfaces. To do this
      we interpolate the volume onto the surface of each subject, then
      average. Unfortunately reading and writing volume data is messy,
      because it comes in so many different formats. Readers and writers
      are provided for MINC (<code>.mnc</code>), ANALYZE (<code>.img</code>),
      NIFTI (<code>.nii</code>) or AFNI (<code>.brik</code>) format. All
      the matlab functions for ANALYZE (<code>.img</code>) and NIFTI (<code>.nii</code>)
      are included with SurfStat. If you are using AFNI (<code>.brik</code>)
      formatted files, you will need to install the <a
        href="http://afni.nimh.nih.gov/afni/matlab">AFNI Matlab Library</a>
      and set the matlab path as <a href="#install">here</a>.
      <p>
        If you are using MINC (<code>.mnc</code>) formatted files you
        will need the extra tools in the
        <a href="http://www.bic.mni.mcgill.ca/software/emma">emma</a>
        toolbox also available for
        <a
          href="http://www.bic.mni.mcgill.ca/users/bert/emma-0.9.7-win32.zip">
          Windows</a> and <a
          href="http://www.bic.mni.mcgill.ca/users/bert/emma-0.9.7-linux.tar.gz">
          Linux</a>.
        Installing the Windows and Linux versions is a bit tricky.
        In the zipped file that you download, there are <code>.dll</code>
        files and <code>.exe</code> files -
        these must be moved to a directory in the operating system path,
        e.g. the <code>matlab/bin/win32</code> directory.
        Also you must create a directory <code>c:/tmp</code> or <code>/tmp</code>
        for
        emma to use as scratch space. Finally you must set the matlab
        path to the emma directory, as <a href="#install">here</a>. To
        test it out, see if you can read the MINC template file
        supplied with SurfStat:
      </p>
      <xmp>
fid = fopen( 'icbm_template_2.00mm.mnc' )
template = fopen( fid )
fclose( fid )
vol = SurfStatReadVol1( template )
</xmp>A common error at this stage is forgetting to move the <code>.dll</code>
      files and <code>.exe</code> files into the path of the operating
      system. If you don't get any red error messages, it has worked!
      Now check to see if you can write
      a MINC file:
      <xmp>
vol.file_name = 'test.mnc';
SurfStatWriteVol1( vol )
</xmp>A common error at this stage is forgetting to make the <code>c:/tmp</code>
      or <code>/tmp</code> directories. Again if there are no red
      warning messages, you should have written a MINC file called <code>test.mnc</code>
      in your working directory (it will just contain zeros).
      Congratulations!
      <p>
        Now we are ready for the real thing. First read in your
        volumetric data from <code>c:/keith/surfstat/myfile.mnc</code>:
      </p>
      <xmp>
vol = SurfStatReadVol1( 'c:/keith/surfstat/myfile.mnc' );
</xmp>Once that is done, we then read in all the surface data (this
      takes a few minutes):
      <xmp>
surfs = SurfStatReadSurf( filesboth );
</xmp>To interpolate the volume to the surface:
      <xmp>
s = SurfStatVol2Surf( vol, surfs );
SurfStatView( s, avsurf );
</xmp>To do the reverse, and interpolate the surface data in <code>s</code>
      to a volume <code>vol2</code>, then write it to <code>c:/keith/surfstat/myfile2.mnc</code>:
      <xmp>
vol2 = SurfStatSurf2Vol( s, surf);
vol2.file_name = 'c:/keith/surfstat/myfile2.mnc';
SurfStatWriteVol1( vol2 );
</xmp>It is instructive to view the two files <code>c:/keith/surfstat/myfile.mnc</code>
      and <code>c:/keith/surfstat/myfile2.mnc</code> side by side. If
      you are using MINC files, then <code>register</code> is
      convenient (go <a
        href="http://www.bic.mni.mcgill.ca/users/fmorales/register.zip">here</a>
      for a Windows version). You can call it up from within Matlab as
      follows:
      <xmp>
!"C:\Program Files\MATLAB\R2007b\toolbox\local\emma\register.exe" -rgb c:/keith/surfstat/myfile.mnc c:/keith/surfstat/myfile2.mnc &amp;
</xmp>You will see that <code>c:/keith/surfstat/myfile2.mnc</code> has
      chunks of data missing in places where there are no cortical
      surfaces. Also you will notice that <code>c:/keith/surfstat/myfile2.mnc</code>
      is a lot smoother looking than the original <code>c:/keith/surfstat/myfile.mnc</code>
      because the surfaces that it interpolates onto are all different.
      The different surfaces have the effect of blurring the data.
      <p>
      </p>
      <hr>
      <a name="mixed"></a>
      <h3>Mixed effects, a.k.a. longitudinal data, a.k.a. repeated
        measures</h3>
      Mixed effects models are used when the observations are not
      independent with equal variances. This happens when there is
      longitudinal data or repeated measurements on a subject, which
      tend to be positively correlated, or when there are different
      variances for different groups of subjects. Both can be handled by
      mixed effects models. The simplest case is when the data set
      consists of subjects each with several measurements. The data set
      just analysed only has one measurement per subject, so there is no
      need for a mixed effects analysis. So to illustrate the methods, I
      shall create a fake data set. I shall pretend that all subjects
      with the same age (in years) and gender are the same "Subject"
      (never do this in real life!). The result is 35 "Subjects" with
      indices as follows (I have sorted the data by age within gender,
      so that the output looks nicer):
      <xmp>
[ u, i, subj ] = unique( [ floor( age ) Gender.male ], 'rows' );
num2str(subj')
2   2   2   2   2   2   2   2   4   4   4   4   4   4   6   6   6
6   6   6   6   8   8   8   8   8   8   8  10  10  10  10  10  12
12  12  12  12  12  14  14  14  14  14  14  14  16  16  16  18  18
18  20  20  22  22  22  24  24  24  27  27  33  34   1   1   1   1
1   3   3   3   3   3   5   5   5   7   7   7   7   7   9   9   9
9   9  11  11  11  11  11  11  13  13  13  13  13  13  13  13  13
13  15  15  15  15  17  17  17  17  17  17  19  19  19  19  19  21
21  21  21  23  23  23  23  23  23  23  25  25  25  25  25  25  25
26  26  28  29  29  30  30  31  32  32  35
Subj = term( var2fac( subj ) );
</xmp>The last line converts <code>subj</code> to a cell array of
      strings, then to a term. What can we do with <code>Subj</code>?
      There are three choices; the first one is to ignore <code>Subj</code>,
      as <a href="#ICBMagain">above</a>:
      <xmp>
M1 = 1 + Age + Gender;
image( M1 );
</xmp><a href="figs/M1.jpg"><img src="figs/tn_M1.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Suppose in fact there are correlations between observations on
        the same subject. Then coefficients of fixed effects (<code>Age</code>
        and <code>Gender</code>) are still unbiased but less precise.
        But most importantly, their estimated standard deviations are
        biased (usually too small), so that the resulting T statistics
        are wrong (usually too big). One possibiility is to allow for <code>Subj</code>
        as a fixed effect:
      </p>
      <xmp>
M2= 1 + Age + Gender + Subj;
image( M2 );
</xmp><a href="figs/M2.jpg"><img src="figs/tn_M2.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        (The image is a horrible mess because the 35 <code>Subj</code>
        indicators dominate.) This model also gives unbiased estimates
        of fixed effects (<code>Age</code> and <code>Gender</code>),
        but again they are less precise. The reason is that by allowing
        for a fixed effect of <code>Subj</code>, all our inference
        comes from differences <i>within</i> a subject. We are throwing
        away information from age or gender differences <i>between</i>
        subjects. In particular, we are throwing away any subject with
        just one observation, i.e. the 5 subjects (#28, 31, 33, 34, 35).
        We are only using age information within a subject. It is as if
        all subjects had the same age (in years).</p>
      <p>
        Age effects are only inferred from the monthly effect within
        each subject, and information about age effects between subjects
        is lost. Nevertheless, inference about the age effects that
        remain are valid even if the observations within a subject are
        equally correlated. In other words, the estimated standard
        deviation of the age effects are unbiased, and T statistics have
        the correct null distribution. This analysis is better than <code>M1</code>,
        at least for age.</p>
      <p>
        However it is a disaster for gender: it is now impossible to
        estimate gender, because gender only varies between subjects,
        and we have just removed a subject effect!.</p>
      <p>
        The solution is to try a mixed effects model:
      </p>
      <xmp>
M3 = 1 + Age + Gender + random( Subj );
image( M3 );
</xmp><a href="figs/M3.jpg"><img src="figs/tn_M3.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Here we have made <code>Subj</code> into a random effect,
        meaning that its coefficients are independent Gaussian random
        variables. This induces equal correlations between observations
        on the same subject. On the right you will see the model for the
        variance of the observations. We have forgotten to add the
        identity matrix <code>I</code> to allow for independent "white"
        noise in every observation (this is added by default to any
        fixed effect model, but it must be specifically added to a mixed
        effects model):
      </p>
      <xmp>
M3 = 1 + Age + Gender + random( Subj ) + I;
image( M3 );
</xmp><a href="figs/M3I.jpg"><img src="figs/tn_M3I.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        The variance is now a linear model with two "variables", a
        matrix with 1's in each subject, plus the identity matrix with
        1's down the diagonal. This mixed effects model <code>M3</code>
        lies somewhere between the two fixed effects models <code>M1</code>
        and <code>M2</code>. In <code>M3</code>, if the variance of <code>random(
          Subj )</code> is 0, you get <code>M1</code>; if the variance
        of <code>random( Subj )</code> is infinite, you get <code>M2</code>.
        Model <code>M3</code> estimates a variance in between.
        You might be curious to know that if the design is balanced then
        inference about the age effect is the same in <code>M2</code>
        as in <code>M3</code>. A balanced design has the same number of
        observations at the same time instants (e.g. at ages 21.0, 21.5,
        21.75 years) on each subject.</p>
      <p>
        The rest of the analysis proceeds as before. <code>SurfStatLinMod</code>
        fits model <code>M3</code> by first fitting <code>M1</code>.
        It then uses the residuals to estimate the variance model by <a
          href="http://en.wikipedia.org/wiki/Reml">ReML</a>. The fixed
        effects and the overall variance are re-estimated, again by <a
          href="http://en.wikipedia.org/wiki/Reml">ReML</a>. Thus all
        parameter estimates are approximately unbiased. If this
        procedure were iterated, it would converge to the <a
          href="http://en.wikipedia.org/wiki/Reml">ReML</a> estimates,
        but this takes much more time, and the resulting estimates are
        not much different. If you are worried about this, you should
        use Jason Lerch's
        <a
          href="http://wiki.bic.mni.mcgill.ca/index.php/ThicknessStatistics">Thickness
          Statistics</a> which calls <a
          href="http://en.wikipedia.org/wiki/R_%28
          programming_language%29">R</a>'s <a
          href="http://cran.r-project.org/web/packages/nlme/index.html"><code>nlme</code></a>,
        but it is much more time consuming (up to 1 day per fit!). <a
          href="http://cran.r-project.org/web/packages/nlme/index.html"><code>nlme</code></a>
        will also fit more elaborate models such as an AR(p) time-series
        model for the correlation structure, which is not implemented in
        SurfStat.</p>
      <p>
        Here we go:
      </p>
      <xmp>
slm = SurfStatLinMod( Y, M3, avsurf )
SurfStatView( slm.r.*mask, avsurf, 'Correlation within subject' );
</xmp><a href="figs/Rmix.jpg"><img src="figs/tn_Rmix.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        <code>slm.r</code> contains the estimated correlation within
        subjects. It is clamped to a minimum of a small positive number
        to avoid a non-positive definite variance matrix. Most of the
        image is in fact clamped, indicating no correlations within
        "subjects". This is what we expect, since the "subjects" are
        fake. The results for a negative age effect (atrophy) are:
      </p>
      <xmp>
slm = SurfStatT( slm, -age )
mean( slm.dfs( find(mask) ) )
   54.9440
SurfStatView( slm.t.*mask, avsurf, 'T stat for -age, 54.9 df' );
</xmp><a href="figs/Tagemix.jpg"><img src="figs/tn_Tagemix.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        The first thing to note is that the degrees of freedom is not
        equal to #observations - #variables = 147 - 3 = 144 as for <a
          href="#T"><code>M1</code></a>. It is not even an integer. It
        is a non-integer <i>effective</i> degrees of freedom that
        varies spatially (since the variance model varies spatially),
        and is available in <code>slm.dfs</code>. Its average inside
        the mask is 54.9, and this is used for the P-value calculations
        (not shown). For a gender effect:
      </p>
      <xmp>
slm = SurfStatT( slm, Gender.male - Gender.female )
mean( slm.dfs( find(mask) ) )
   25.3734
SurfStatView( slm.t.*mask, avsurf, 'T stat for male-female, 25.4 df' );
</xmp><a href="figs/Tmfmix.jpg"><img src="figs/tn_Tmfmix.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Note that you get different degrees of freedom for different
        contrasts, unlike for <a href="#T"><code>M1</code></a>. Now the
        degrees of freedom is less. Why? Essentially because gender is
        estimated between subjects, and there are only 35 subjects, so
        the degrees of freedom has to be less than 35.</p>
      <p>
        More elaborate models are possible. It is common practice to
        assume that the interaction between a fixed effect and a random
        effect is also random. In the case of age, this allows for a
        random age slope for different subjects. The test for the age
        main effect still makes sense: it is testing to see if the mean
        of these random slopes is different from 0. To do this:
      </p>
      <xmp>
M = 1 + Age + Gender + random(Subj) + Age*random(Subj) + I;
image( M );
</xmp><a href="figs/MA1.jpg"><img src="figs/tn_MA1.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        It turns out that this model is not appropriate because it is
        not invariant to a rescaling of age. If for instance we measured
        age from a baseline of (say) 18 years, then the fitted model
        would be different. To overcome this, we need to allow for a
        covariance between the random age-subject interaction and the
        random subject main effect, which can be written in two
        identical ways:
      </p>
      <xmp>
M = 1 + Age + Gender + ( 1 + Age )*random(Subj) + I;
M = Gender + ( 1 + Age )*( 1 + random(Subj) ) + I;
image( M );
</xmp><a href="figs/MA2.jpg"><img src="figs/tn_MA2.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Now there are two extra components that allow for the
        covariance. As a result, fitting takes a little longer:
      </p>
      <xmp>
slm = SurfStatT( slm, -age )
mean( slm.dfs( find(mask) ) )
   12.6669
SurfStatView( slm.t.*mask, avsurf, 'T stat for -age, 12.7 df' );
</xmp><a href="figs/Tagesubjmix.jpg"><img src="figs/tn_Tagesubjmix.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        The df has gone down from 54.9 to 12.7. The reason is that if we
        assume that there is a different age slope for each subject,
        then the age sd is now estimated between the 30 subjects with at
        least two observations, so the age sd has to have less than 30
        degrees of freedom. The 30 is reduced even more, since more
        weight is put on the few subjects with larger numbers of
        observations. In general, you lose degrees of freedom as the
        variance model becomes more elaborate, which means you lose
        sensitivity to detect effects. </p>
      <p>
        So my advice is to stick to simple models, such as <code>M3</code>,
        unless there is strong evidence to the contrary. You might be
        curious to know that <a
          href="http://www.math.mcgill.ca/keith/fmristat/">
          FmriStat</a> (and all the other common packages such as SPM
        and FSL) do in fact allow for an interaction between fixed
        effects and random effects. This is implemented by finding one
        slope per subject, throwing the rest of the data away, then
        combining the slopes in another linear model. The reason why it
        is appropriate for fMRI data is that the number of repeated
        measures in an fMRI time series is huge (100-200) compared to
        the number of repeated measures here (1-10). This means that
        sd's can be estimated very accurately within subjects, there is
        no need to pool sd information between subjects, and so no need
        for a complex mixed effects model.</p>
      <p>
        Finally, it is possible to do <a
          href="http://en.wikipedia.org/wiki/Welch's_t_test">Welch's T
          test</a>, which tests for a difference in group means allowing
        for a difference in variance. For example, to test for a
        difference in gender, allowing for different variances for males
        and females, but ignoring age and subject,
      </p>
      <xmp>
M = 1 + Gender + Gender * I;
image( M );
</xmp><a href="figs/MG.jpg"><img src="figs/tn_MG.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Actually the model is over-parameterized. To reduce the model by
        eliminating redundant variables both for mean and variance:
      </p>
      <xmp>
M = redmod ( M );
image( M );
</xmp><a href="figs/MGr.jpg"><img src="figs/tn_MGr.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Now it is clearer what is going on: there is a separate mean for
        males and females, and a separate variance for males and
        females. The effective degrees of freedom is 137.3, down
        slightly from the 147 - 2 = 145 without allowing for separate
        variances, which is the price you pay for allowing for separate
        variances. </p>
      <p>
        The most general model would be to interact all fixed effects
        with all random effects:
      </p>
      <xmp>
M = redmod( ( 1 + Age + Gender )*( 1 + random( Subj ) ) + I );
image( M );
</xmp><a href="figs/MM.jpg"><img src="figs/tn_MM.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Apart from taking a long time to fit, such a model leaves too
        little degrees of freedom to make any useful inference.</p>
      <p>
        So far only T tests for univariate mixed effects models are
        implemented - F tests and multivariate mixed effects models are
        yet to come.</p>
      <p>
        <font color="red">A final note of caution:</font> the methods
        used to fit mixed effects models are only approximate.
        Convergence is not guaranteed. The way in which the model is
        forced to have a positive definite variance matrix restricts the
        types of correlation structures. The method is not completely
        invariant to a linear re-parameterization, even if fixed effects
        terms are added before crossing with a random effect as
        recommended above. However the algorithm will give <i>exact</i>
        results for a single random effect if the design is balanced. It
        will also give <i>exact</i> results for Welch's test even if
        the grouping factor has more than one group. In general it will
        give good results whenever there is just one additive random
        effect, such as <code>random(Subj)</code>, so my suggestion is
        to stick to that.
      </p>
      <hr>
      <a name="map"></a>
      <h3>Memory mapping</h3>
      This section can be skipped unless you are curious about what
      happens "under the hood". For most purposes, you will not need to
      know what memory mapping is, or how it works, or even when it is
      being used, because all <code>SurfStat</code> functions handle
      memory mapping without you knowing. However there might be
      occasions when you need to know where your data is really stored,
      in which case, read on.
      <p>
        When the amount of data is big, it can exceed the available
        memory. In this case, the three functions that read data (<code>SurfStatReadSurf</code>,
        <code>SurfStatReadData</code>, <code>SurfStatReadVol</code>)
        all resort to memory mapping instead of reading the data into
        memory. Memory mapping is invoked if the total storage exceeds
        64Mb of memory. You can change this memory limit to e.g. 128MB
        by issuing the following command:
      </p>
      <xmp>
global MAXMEM; MAXMEM=128;
</xmp>or by adding an extra argument - see the <code>help</code> for
      the reader.
      <p>
        Memory mapping works as follows. The data is first written to a
        temporary file as 4 byte reals. The temporary file is in a
        directory <code>SurfStat</code> in the same directory as the
        first file to be read in. This directory will be created if it
        doesn't exist already. If it can't be created because you don't
        have permission, then an error message will be produced
        prompting you to supply a directory where you do have permission
        to write. <font color="red">Note that neither the temporary
          file, nor the temporary directory, are ever deleted. To avoid
          wasted disk space, you should delete these files after you
          have quit Matlab.</font></p>
      <p>
        Then the output parameter of the reader, say <code>Y</code>, is
        a special structure that contains information on the name of the
        file where the data is stored, the format, and the dimensions of
        the data array (see below for an example). You can access the
        data by:
      </p>
      <xmp>
Y.Data(1).Data
</xmp>If the data is 2D, then this is a an array of dimensions
      (#vertices × #data files). If the data is 3D, then this is a an
      array of dimensions (#vertices × #components or coordinates ×
      #data files). For example, to access 2D data at vertex 1000, files
      5 to 20, use:
      <xmp>
Y.Data(1).Data( 1000, 5:20 )
</xmp>To access 3D data at vertices 100, 200, 400, all components, and
      file 6 use:
      <xmp>
Y.Data(1).Data( [100 200 400], :, 6 )
</xmp>You can treat this exactly like an ordinary variable; you can for
      instance copy the data to a variable:
      <xmp>
Y1 = Y.Data(1).Data( 1000, 5:20 )
</xmp>or write a variable to the memory mapped data:
      <xmp>
Y.Data(1).Data( [100 200 400], :, 6 ) = Y2
</xmp>All the <code>SurfStat</code> functions will handle memory mapped
      data where appropriate.
      <p>
        As an example of memory mapping, we shall analyze the trivariate
        coordinates of the surfaces
        themselves. We shall see if coordinates depend on age allowing
        for a difference in coordinates between males and females. First
        we must read in all the surface data (this takes a few minutes):
      </p>
      <xmp>
surfs = SurfStatReadSurf( filesboth );
</xmp>Since the amount of data 147 × 81924 × 3 × 4 = 138Mb exceeds the
      limit of 64Mb, then the data is memory mapped rather than read
      into memory. In the case of <code>SurfStatReadSurf</code>, only <code>surfs.coord</code>
      is memory mapped, and <code>surfs.tri</code> is read into memory
      in the usual way. To see this, type:
      <xmp>
&gt;&gt; surfs
      tri: [163840x3 int32]
    coord: [1x1 memmapfile]
</xmp>Investigating further:
      <xmp>
&gt;&gt; surfs.coord
    Filename: 'c:\keith\fMRI\ICBM\surfaces\SurfStat\tp95705ccb_c494_43e5_991a_fed16698f279'
    Writable: true
      Offset: 0
      Format: {'single' [81924 3 147] 'Data'}
      Repeat: Inf
        Data: 1x1 struct array with fields:
             Data
</xmp><code>Filename</code> is the memory mapped file. It is mapped as a
      81924 × 3 × 147 single precision array. To access all the
      coordinates of vertex 1000 on subjects 20 and 25:
      <xmp>
&gt;&gt; surfs.coord.Data(1).Data( 1000, :, [20 25] )
   -2.8642   16.7308   -4.1040
   -0.6023   19.9366   -4.6526
</xmp>To view the surface of subject 15:
      <xmp>
test.coord = surfs.coord.Data(1).Data( :, :, 15 )';
test.tri = surfs.tri;
SurfStatView( [], test, 'Subj 1000' );
</xmp>
      <hr>
      <a name="smooth"></a>
      <h3>Smoothing</h3>
      To better detect differences over a broader region, we shall first
      smooth the coordinates read in above. How much to smooth? It
      depends on how big the features are that you wish to detect. To
      detect 20mm features, you should use a 20mm FWHM filter. Of course
      you never know how big the features are in advance, so you have to
      make a guess. Since the cortical thickness data was smoothed 20mm,
      we shall do the same to the coordinates:
      <xmp>
Y = SurfStatSmooth( surfs.coord, avsurf, 10 );
</xmp>The last parameter, 10, is the FWHM in mesh units. Since the mesh
      size of our data is about 2mm on average, then this will give
      roughly 20mm smoothing. Note that smoothing is usually the most
      time-consuming step; the above smoothing took 26 minutes on my
      2-year-old laptop!
      To take a look at the smoothed coordinates of the first subject
      (00100), coloured by cortical thickness (compare this to the
      unsmoothed coordinates <a href="#s100">above</a>):
      <xmp>
s100smooth.coord = Y.Data(1).Data( :, :, 1 )';
s100smooth.tri = surfs.tri;
SurfStatView( t100, s100smooth, 'Subj 00100 smoothed 20mm' );
</xmp><a href="figs/s100smooth.jpg"><img src="figs/tn_s100smooth.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
      </p>
      <hr>
      <a name="multi"></a>
      <h3>Multivariate data statistical analysis</h3>
      Statistical analysis now proceeds exactly as for univariate data,
      except that the T statistic is now the maximum over all linear
      combinations of the variates. In other words, we take the maximum
      of the T statistics for the x coordinate, the y coordinate, the z
      coordinate, and all possible linear combinations such as x+y or
      0.1*x+0.4*y-0.3*z. This maximum T is known as Hotelling's T (the
      square root of <a
        href="http://en.wikipedia.org/wiki/Hotelling%27s_T-square_distribution">Hotelling's
        T<sup>2</sup></a>). The same idea applies to the F statistic,
      which is now the maximum F over all linear combinations. This is
      known as <a
href="http://mrw.interscience.wiley.com/emrw/9780470011812/eob/article/b2a10081/current/abstract">Roy's
        maximum root</a>. Random field corrected P-values for peaks and
      clusters are available.
      <p>
        As an example, let's look for an age effect on the smoothed
        surface coordinates, allowing for gender.
      </p>
      <xmp>
slm = SurfStatLinMod( Y, Gender + Age, avsurf );
slm = SurfStatT( slm, age );
h = SurfStatView( slm.t.*mask, avsurf, 'Max T for age effect on coordinates' );
</xmp><a href="figs/coordaT.jpg"><img src="figs/tn_coordaT.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        It's interesting to compare this with the <a href="#T">T
          statistic for an age effect on cortical thickness</a>. However
        before getting excited, we should find out the corrected
        threshold:
      </p>
      <xmp>
resels = SurfStatResels( slm, mask )
    2.0000    4.5114  228.9485
stat_threshold( resels, length(slm.t), 1, slm.df, [], [], [], [], slm.k )
    5.1849
</xmp>Note that this is larger than the <a href="#thresh">4.4259</a>
      for the univariate T-statistic (even though the resels are
      smaller) - this is the price you pay for searching over all linear
      combinations of the multivariate data to get the maximum T
      statistic.
      <p>
        Unfortunately the P-values for peaks and clusters are not
        significant:
      </p>
      <xmp>
[ pval, peak, clus ] = SurfStatP( slm, mask );
term( peak )

  t       vertid  clusid  P
---------------------------------
  4.3592   1806   1       0.83991
  4.2794  28210   2        1.0707
  4.1982  16539   3        1.3633

term(clus)

  clusid  nverts  resels      P
-------------------------------------
  1       53        0.016794  0.30263
  2       14       0.0041732   0.5022
  3        6      0.00024013  0.68522
</xmp>Why is <code>P&gt;1</code> for the last two peaks? The reason is
      that <code>P</code> approximates the expected number of peaks
      above <code>t</code>, which only approximates the P-value if <code>P</code>
      is small, say less than 0.1.
      Both the P-value and Q-value images are blank, so we don't show
      them, but here's the code:
      <xmp>
SurfStatView( pval, avsurf, 'Max T for age effect on coordinates' );
SurfStatView( SurfStatQ( slm, mask ), avsurf, 'Max T for age effect on coordinates' );
</xmp>Even though the peak at 1806 is not significant, here are the age
      effects on the x, y and z coordinates, their sd, and (univariate)
      T statistics:
      <xmp>
[ slm.ef(:, 1806)  slm.sd(:, 1806)  slm.ef(:, 1806)./slm.sd(:, 1806) ]
    0.0528    0.0237    2.2242
    0.0434    0.0306    1.4179
    0.0742    0.0223    3.3248
</xmp>Note that the univariate T statistics are all less than the
      maximum T statistic of 4.3586 (obviously). If this was
      significant, it would suggest, for example, that z coordinates
      increase by 0.07 ± 0.02 mm per year at this point near the right
      cingulate.
      <p>
        Here's an even better way of showing the movement of the surface
        with age. We can use Matlab's <code>quiver3</code> to show the
        age effects in <code>slm.ef</code> as little arrows. First
        let's pick three local maxima in the table above as origins for
        the arrows, then find their coordinates (the rows are <code>x</code>,
        <code>y</code>, <code>z</code>, the columns are the vertices):
      </p>
      <xmp>
id = [ 1806 28210 16539 ];
coord = SurfStatInd2Coord( id, avsurf )

   -9.2008   -6.5057   -5.4116
   16.7131   14.8676   36.2732
   33.1974   50.9881   14.2673
</xmp>Now for a bit of Matlab code. We want to add the arrows to each of
      the axes in the above figure. Luckily we have saved the axis
      handles in <code>h</code> by putting <code>h</code> as the
      output of the <code>SurfStatView</code> function above. Then we
      loop over axes, adding red arrows in the positive direction and
      blue arrows in the negative direction, so we can always see the
      arrows:
      <xmp>
for i = 1:8
    axes( h(i) );
    hold on;
    quiver3( coord( 1, : ), coord( 2, : ), coord( 3, : ), ...
        slm.ef( 1, id ), slm.ef( 2, id ), slm.ef( 3, id ), ...
        'LineWidth',2, 'Color','red' );
    quiver3( coord( 1, : ), coord( 2, : ), coord( 3, : ), ...
        -slm.ef( 1, id ), -slm.ef( 2, id ), -slm.ef( 3, id ), ...
        'LineWidth',2, 'Color','blue' );
    hold off;
end
</xmp>Let's zoom in on one of the axes by hitting the "+" magnifying
      glass in the figure tool bar:
      <p>
        <a href="figs/coordaTa.jpg"><img src="figs/tn_coordaTa.jpg"
            alt="[Click to enlarge image]" border="0"></a></p>
      <p>
        (Note that the arrows are not to scale.) The red arrows are
        pointing up and away from the brain centre, suggesting a
        movement of anatomy in that direction with increasing age.
        However we shouldn't read too much into this, because the
        P-values are not significant.</p>
      <p>
        Finally, let's test for a quadratic age effect, allowing for
        gender, using the maximum F statistic (<a
href="http://mrw.interscience.wiley.com/emrw/9780470011812/eob/article/b2a10081/current/abstract">Roy's
          maximum root</a>):
      </p>
      <xmp>
slm0 = SurfStatLinMod( Y, Gender );
slm = SurfStatLinMod( Y, Gender + Age + Age^2, avsurf )
slm = SurfStatF( slm, slm0 );
SurfStatView( slm.t.*mask, avsurf, 'Max F for quadratic age effect (2,143 df)' );
</xmp><a href="figs/coordaF.jpg"><img src="figs/tn_coordaF.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        The corrected P-values are not significant, but there is one
        significant cluster:
      </p>
      <xmp>
[ pval, peak, clus ] = SurfStatP( slm, mask );

term( peak )

  t        vertid  clusid  P
----------------------------------
  13.5506  20342   2       0.24231
  13.2001  14465   1        0.3077
  11.5435  72311   4        0.9336
  11.4164  12566   3        1.0149
   11.375  50254   5        1.0442
  11.3442  78056   5         1.066

term(clus)

  clusid  nverts  resels    P
------------------------------------
  1       108       0.09532  0.048088
  2        38       0.06083  0.091886
  3        73      0.019981   0.26443
  4        23     0.0095408   0.39397
  5        24     0.0068077   0.44802

SurfStatView( SurfStatP( slm, mask ), avsurf, 'Max F for quadratic age effect (2,143 df)' );
SurfStatView( SurfStatQ( slm, mask ), avsurf, 'Max F for quadratic age effect (2,143 df)' );
</xmp>The Q-value image is blank (not shown), but the P-value image
      shows the single cluster just inside the right temporal lobe:
      <p>
        <a href="figs/coordaFP.jpg"><img src="figs/tn_coordaFP.jpg"
            alt="[Click to enlarge image]" border="0"></a></p>
      <p>
        What is going on at the peak inside this region (<code>id=14465</code>)?
        Here's plot of the x,y,z coordinates against age for males and
        females separately:
      </p>
      <xmp>
clf;
xyz='xyz';
for j=1:3
    subplot(2,3,j)
    SurfStatPlot( age(find(Gender.male)), Y(find(Gender.male), 14465, j) );
    title('Male'); legend off; xlabel('age'); ylabel(xyz(j)); xlim([18,45])
end
for j=1:3
    subplot(2,3,j+3)
    SurfStatPlot( age(find(Gender.female)), Y(find(Gender.female), 14465, j) );
    title('Female'); legend off; xlabel('age'); ylabel(xyz(j)); ; xlim([18,45])
end
</xmp><a href="figs/coordaFPlot.jpg"><img src="figs/tn_coordaFPlot.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Looks like the quadratic effect is caused by one male and one
        female (ages 45 and 42, respectively) with very low z
        coordinate.
      </p>
      <hr>
      <a name="vbm"></a>
      <h3>VBM data</h3>
      Here's an example of voxel based morphometry (VBM) data, analyzed
      in <a
        href="http://www.math.mcgill.ca/keith/royni/royni_abstract.htm">Worsley
        et al. (2004)</a>. There are two groups of subjects: a group of
      19 subjects with non-missile trauma, and a group of 19 age and
      gender matched controls. Damage due to the trauma is expected in
      white matter, so the data consists of white matter density
      smoothed 10mm. Naturally we are interested in the difference
      between trauma and control groups, so the model is particularly
      simple. First we need a list of the 38 file names:
      <xmp>
filenames = SurfStatListDir( 'C:/keith/fMRI/francesco/wm2/' );
</xmp>Since the data is quite big (91 × 109 × 91 × 38 × 4 = 131Mb) we
      have to be careful about reading the data. The first thing might
      be to look at just one slice of the data, say the slice with <code>z=0</code>,
      laid out in two groups of trauma and control. To do this, we first
      read in just the one slice with <code>z</code> coordinate <code>0</code>
      from all data sets, which easily fits into memory:
      <xmp>
[ Y0, vol0 ] = SurfStatReadVol( filenames, [], { [], [], 0 } );
</xmp>The second parameter, left empty for the moment, is to allow for a
      mask, while the third specifies that we want all <code>x</code>
      slices, all <code>y</code> slices, but just the one slice with <code>z=0</code>.
      We then use
      <code>SurfStatViews</code> (the <code>s</code> is for slice) with
      a last parameter, <code>layout</code>, which is a matrix which
      lays
      out the slices (in the order in filenames) where you want them in
      the
      array of images (0 leaves out an image). The variable <code>control</code>
      indicates with a 1 which files are in the control group, in the
      order in <code>filenames</code>:
      <xmp>
control=[0 0 1 1 1 1 0 1 1 0 0 0 0 1 0 0 0 1 ...
    0 1 0 1 0 1 1 0 1 1 1 0 1 1 1 0 0 0 0 1];
layout = reshape( [ find(1-control) 0 find(control) 0], 5, 8 )
     1    12    19    34     3     9    24    31
     2    13    21    35     4    14    25    32
     7    15    23    36     5    18    27    33
    10    16    26    37     6    20    28    38
    11    17    30     0     8    22    29     0
clf; SurfStatViews( Y0, vol0, 0, layout );
title('WM demsity for 19 trauma subjects (left) and 19 controls (right)');
</xmp><a href="figs/vbm.jpg"><img src="figs/tn_vbm.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Even to the naked eye, it looks like the trauma group has less
        WM than the control group. To save storage, we now find a mask
        based on the average white matter density in the control group:
      </p>
      <xmp>
[ wmav, volwmav ] = SurfStatAvVol( filenames( find(control) ) );
</xmp><code>SurfStatView1</code> is a viewer for both volumetric and
      surface data with only one view (hence the name). By default it
      will show three orthogonal slices through the middle of the data:
      <xmp>
clf; SurfStatView1( wmav, volwmav );
</xmp><a href="figs/vbmmask1.jpg"><img src="figs/tn_vbmmask1.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Now we need to choose a suitable threshold to mask the white
        matter. 0.05, i.e. 5% or more white matter, looks like a good
        choice. To check this, add a thresholded image at 0.05 by
        leaving out the <code>clf</code> command (which clears the
        figure window):
      </p>
      <xmp>
SurfStatView1( wmav, volwmav, 'datathresh', 0.05 );
</xmp><a href="figs/vbmmask2.jpg"><img src="figs/tn_vbmmask2.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Other properties such as the colour and transparency can be
        modified, see the help of <code>SurfStatView1</code>, and
        strung together in pairs of arguments after <code>volwmav</code>.</p>
      <p>
        Now we are ready to read in all the data inside the mask. If
        there is a lot of data, <code>SurfStatReadVol</code> uses
        memory mapping rather than loading all the data into memory.
      </p>
      <xmp>
[ Y, vol ] = SurfStatReadVol( filenames, wmav &gt; 0.05 );
</xmp>However by specifying a mask where average WM&gt;0.05, we have cut
      down storage from 131Mb to 26Mb, so memory mapping is not
      necessary. If you wanted to speed things up by cutting the storage
      down even more, you can read in every 2nd voxel using:
      <xmp>
[ Y, vol ] = SurfStatReadVol( filenames, wmav &gt; 0.05, 2 );
</xmp>We'll stick with the full data, which gives nicer pictures.
      Setting up the group factor is easy:
      <xmp>
Group = term( var2fac( control, { 'trauma'; 'control' } ) );
</xmp>Now we fit the model and test for a difference between trauma and
      control. Naturally we want control minus trauma, since we expect
      WM density to have decreased in the trauma group:
      <xmp>
slm = SurfStatLinMod( Y, Group, vol );
slm = SurfStatT( slm, Group.control - Group.trauma );
clf; SurfStatView1( slm.t, vol );
title( 'T-statistic, 36 df' );
</xmp><a href="figs/vbmt.jpg"><img src="figs/tn_vbmt.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Of course you may prefer to write out the T-statistic so you can
        load it into your own favourite viewer:
      </p>
      <xmp>
SurfStatWriteVol( 'c:/keith/surfstat/data/tstat.mnc', slm.t, vol );
</xmp>Now for the P-values:
      <xmp>
clf; SurfStatView1( SurfStatP( slm ), vol );
title( 'P-value&lt;0.05' );
</xmp>The red blobs are local maxima with P&lt;0.05, and the transparent
      blue blobs are
      the clusters with extents that have P&lt;0.05:
      <p>
        <a href="figs/vbmp.jpg"><img src="figs/tn_vbmp.jpg" alt="[Click
            to enlarge image]" border="0"></a></p>
      <p>
        The damage is quite extensive, indicating that the white matter
        surrounding the ventricles has atrophied. To see how much
        atrophy, let's look at the estimated effect (control minus
        trauma) and its standard error:
      </p>
      <xmp>
clf; SurfStatView1( slm.ef, vol );
title( 'Control - trauma wm' );

clf; SurfStatView1( slm.sd, vol );
title( 'Control - trauma wm sd (34 df)' );
</xmp><a href="figs/vbmef.jpg"><img src="figs/tn_vbmef.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        <a href="figs/vbmsd.jpg"><img src="figs/tn_vbmsd.jpg"
            alt="[Click to enlarge image]" border="0"></a></p>
      <p>
        You may prefer the more traditional view of slices, say every
        10mm from -30mm to 70mm:
      </p>
      <xmp>
layout = reshape( [1:11 0], 3, 4);
clf; SurfStatViews( slm.ef, vol, [-30:10:70], layout );
title( 'Control - trauma wm' );

clf; SurfStatViews( slm.sd, vol, [-30:10:70], layout );
title( 'Control - trauma wm sd (34 df)' );
</xmp><a href="figs/vbmefs.jpg"><img src="figs/tn_vbmefs.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        <a href="figs/vbmsds.jpg"><img src="figs/tn_vbmsds.jpg"
            alt="[Click to enlarge image]" border="0"></a></p>
      <p>
        It looks like the trauma subjects have lost between 20% and 40%
        WM, ± ~5%, in the regions surrounding the ventricles.
      </p>
      <hr>
      <a name="dbm"></a>
      <h3>DBM data</h3>
      Here's an example of deformation based morphometry (DBM) data,
      analyzed in <a
        href="http://www.math.mcgill.ca/keith/royni/royni_abstract.htm">Worsley
        et al. (2004)</a>. This is trivariate volumetric data, where the
      three components are the deformations required to warp each
      subject to an atlas standard. There are two groups of subjects: a
      group of 17 subjects with non-missile trauma, and a group of 19
      age and gender matched controls. Unfortunately the subjects in
      this example are not quite the same as those in the above VBM
      example. Naturally we are interested in the difference between
      trauma and control groups, so the model is particularly simple.
      First a look at the data, which comes in three separate files for
      the <code>x</code>, <code>y</code> and <code>z</code>
      deformation components for each subject. We first read in the file
      names then rearrange them into 17 × 3 and 19 × 3 cell arrays of
      file names as follows:
      <xmp>
filenamestrauma = SurfStatListDir( 'C:/keith/fMRI/francesco/DXYZ_TRAUMA/' );
filenamestrauma = reshape( filenamestrauma, 3, 17 )';

filenamescontrol = SurfStatListDir( 'C:/keith/fMRI/francesco/DXYZ_CONTROLLO/' );
filenamescontrol = reshape( filenamescontrol, 3, 19 )';
</xmp>Let's take a look at slice <code>z=0</code> of all the data,
      arranged in rows of <code>x</code>, <code>y</code> and <code>z</code>
      deformations for the trauma group, followed by <code>x</code>, <code>y</code>
      and <code>z</code> deformations for the control group:
      <xmp>
[ Y0, vol0 ] = SurfStatReadVol( [ filenamestrauma; filenamescontrol ], [], { [], [], 0 } );
layout = [ [ reshape(1:51,17,3); zeros(2,3) ] zeros(19,1) reshape(52:108,19,3) ]'
clf; SurfStatViews( Y0, vol0, 0, layout );
title('Rows are x,y,z deformations for trauma (top) and control (bottom) groups');
</xmp><a href="figs/dbm0.jpg"><img src="figs/tn_dbm0.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        It's hard to see any difference in deformations between trauma
        and control, but at least the data look OK. Next we will need a
        mask. Since the trauma is expected to atrophy the white matter,
        let's form a mask by thresholding average white matter density.
        A file for this has already been created:
      </p>
      <xmp>
[ wm, volwm ] = SurfStatReadVol( 'c:/keith/fMRI/francesco/CNT_AVG_wm_mask.mnc' );
clf; SurfStatView1( wm, volwm );
</xmp><a href="figs/dbmmask1.jpg"><img src="figs/tn_dbmmask1.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        0.05, i.e. 5% or more white matter, looks like a reasonable
        threshold:
      </p>
      <xmp>
SurfStatView1( wm, volwm, 'datathresh', 0.05 );
</xmp><a href="figs/dbmmask2.jpg"><img src="figs/tn_dbmmask2.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Now let's read in all the data, which just exceeds 64Mb, so it
        is memory mapped:
      </p>
      <xmp>
[ Y, vol ] = SurfStatReadVol( [ filenamestrauma; filenamescontrol ], wm &gt; 0.05 );

    Filename: 'C:\keith\fMRI\francesco\DXYZ_TRAUMA\SurfStat\tpb11de523_b7d0_49a1_91ec_0fc7ad1a95c9'
    Writable: true
      Offset: 0
      Format: {'single' [163814 3 36] 'Data'}
      Repeat: Inf
        Data: 1x1 struct array with fields:
             Data
</xmp>Setting up the group factor is easy:
      <xmp>
Group = term( var2fac( [ zeros(1,17) ones(1,19) ], { 'trauma'; 'control' } ) );
</xmp>Now we fit the model and test for a difference between trauma and
      control:
      <xmp>
slm = SurfStatLinMod( Y, Group, vol );
slm = SurfStatT( slm, Group.trauma - Group.control );
clf; SurfStatView1( slm.t, vol );
title( 'Hotelling''s T-statistic, 3,34 df' );
</xmp><a href="figs/dbmt.jpg"><img src="figs/tn_dbmt.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Now for the P-values:
      </p>
      <xmp>
clf; SurfStatView1( SurfStatP( slm ), vol );
title( 'P-value&lt;0.05' );
</xmp><a href="figs/dbmp.jpg"><img src="figs/tn_dbmp.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        The damage is quite extensive, but what are the actual
        deformation differences? We can visualize the deformations by
        adding them as little arrows to the image. To do this, let's
        first select some positions for the arrows. I've chosen
        positions on a lattice of 10mm intervals using Matlab's <code>ndgrid</code>:
      </p>
      <xmp>
[ x, y, z ] = ndgrid( -40:10:40, -50:10:30, -20:10:60 );
</xmp>Then we get the id's of the nearest point in the image:
      <xmp>
id = SurfStatCoord2Ind( [ x(:) y(:) z(:) ], vol );
</xmp>id's outside the mask are set to zero, so to eliminate these:
      <xmp>
id = id( id&gt;0 );
</xmp>Now get the actual coordinates of the remaining points:
      <xmp>
coord = SurfStatInd2Coord( id, vol );
</xmp>The deformation differences are in <code>slm.ef</code> but since
      the deformations are measured from subject to atlas, i.e. atlas
      minus subject, we should flip the sign so that we have trauma
      minus control deformations. Then we can use Matlab's <code>quiver3</code>
      to add the arrows:
      <xmp>
hold on;
quiver3( coord( 1, : ), coord( 2, : ), coord( 3, : ), ...
    -slm.ef( 1, id ), -slm.ef( 2, id ), -slm.ef( 3, id ), 0, ...
    'LineWidth',2, 'Color','yellow' );
hold off;
</xmp><a href="figs/dbmpa.jpg"><img src="figs/tn_dbmpa.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        The "0" as the 7th argument of <code>quiver3</code> ensures
        that the arrows are drawn to scale, that is, they are the real
        movements in anatomy, in mm. Let's zoom in by hitting the "+"
        magnifying glass in the figure tool bar:</p>
      <p>
        <a href="figs/dbmpaz.jpg"><img src="figs/tn_dbmpaz.jpg"
            alt="[Click to enlarge image]" border="0"></a></p>
      <p>
        It looks like the arrows are pointing out from the centre,
        indicating that the ventricles of the trauma subjects have
        expanded, or equivalently, that the white matter surrounding the
        ventricles has atrophied.</p>
      <p> This illustrates nicely how DBM can not only detect where the
        anatomy has changed, but it can also show how the anatomy has
        moved, i.e. the direction of the changes.
      </p>
      <hr>
      <a name="pet"></a>
      <h3>PET data</h3>
      We use SurfStat to analyze the some non-kinetic PET CBF data from
      <a
href="http://www.sciencedirect.com/science?_ob=ArticleURL&amp;_udi=B6WNP-4B9K76J-F&amp;_user=458507&amp;_coverDate=02%2F29%2F2004&amp;_rdoc=4&amp;_fmt=high&amp;_orig=browse&amp;_srch=doc-info(%23toc%236968%232004%23999789997%23482841%23FLA%23display%23Volume)&amp;_cdi=6968&amp;_sort=d&amp;_docanchor=&amp;_ct=33&amp;_acct=C000022002&amp;_version=1&amp;_urlVersion=0&amp;_userid=458507&amp;md5=1e05cdaf5dcb683764fd18182e4a3443">Vafee,
        M.S. &amp; Gjedde, A. (2004). Spatially dissociated
        flow-metabolism coupling in brain activation. <i>NeuroImage</i>,
        21:507-515</a>. This same data has previously analyzed by <a
        href="http://www.math.mcgill.ca/keith/fmristat/">
        FmriStat</a> - see <a
        href="http://www.math.mcgill.ca/keith/fmristat/index_pet.htm">here</a>.
      In this study
      there were 14 subjects with 5 scans per subject. During the first
      4 scans
      the subjects were given a right-hand finger tapping task at four
      different frequencies: 1Hz, 2Hz, 3Hz and 4Hz (labeled <code>h1</code>,
      <code>h2</code>, <code>h3</code> and
      <code>h4</code>). These are to be compared to the 5th scan of rest
      (labeled <code>hb</code>).
      We can get a list of all the 70 PET data files as follows:
      <xmp>
filenames = SurfStatListDir( 'C:/keith/fMRI/manou/cbf_non_kin/' );
</xmp>Since the data is quite big (70 × 128 × 128 × 80 × 4 = 350Mb) we
      have to be careful about reading the data. The first thing might
      be to look at just one slice of the data, say the slice with <code>z=0</code>,
      laid out in a task × subjects matrix. To do this, we first read in
      just the one slice with <code>z</code> coordinate <code>0</code>
      from all data sets, which easily fits into memory:
      <xmp>
[ Y0, vol0 ] = SurfStatReadVol( filenames, [], { [], [], 0 } );
</xmp>The second parameter, left empty for the moment, is to allow for a
      mask, while the third specifies that we want all <code>x</code>
      slices, all <code>y</code> slices, but just the one slice with <code>z=0</code>.
      We then use
      <code>SurfStatViews</code> with a last parameter, <code>layout</code>,
      which is a matrix which lays
      out the slices (in the order in filenames) where you want them in
      the
      array of images:
      <xmp>
layout = reshape( 1:70, 5, 14 )
     1     6    11    16    21    26    31    36    41    46    51    56    61    66
     2     7    12    17    22    27    32    37    42    47    52    57    62    67
     3     8    13    18    23    28    33    38    43    48    53    58    63    68
     4     9    14    19    24    29    34    39    44    49    54    59    64    69
     5    10    15    20    25    30    35    40    45    50    55    60    65    70
clf; SurfStatViews( Y0, vol0, 0, layout );
</xmp><a href="figs/pet1.jpg"><img src="figs/tn_pet1.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        It is obvious that there is a bad scan (#25). In the <a
          href="http://www.math.mcgill.ca/keith/fmristat/index_pet.htm">FmriStat
          analysis</a>, the entire subject subject #5 was dropped from
        the analysis. Here we shall retain all the data on subject #5,
        except the bad scan, and do a mixed effects analysis to recover
        as much information as possible from the data. To exclude the
        bad scan, #25:
      </p>
      <xmp>
filenames = filenames( [1:24, 26:70] );
</xmp>To save storage, we first find a mask where all subjects
      have some data, and only read in this data. To do this we find the
      minimum across subjects:
      <xmp>
[ mindata, volmin ] = SurfStatAvVol( filenames, @min, 0 );
</xmp>The second argument of <code>SurfStatAvVol</code> tells the
      function that we want the minimum over scans (other possible
      choices are <code>@max</code> for the maximum, or <code>@plus</code>
      for the average, which is the default). The third argument
      replaces NaN ("not a number") by 0. <code>SurfStatView1</code> is
      a viewer for both volumetric and surface data with only one view
      (hence the name). By default it will show three orthogonal slices
      through the middle of the data:
      <p>
      </p>
      <xmp>
clf; SurfStatView1( mindata, volmin );
</xmp><a href="figs/petmin.jpg"><img src="figs/tn_petmin.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Now we need to choose a suitable threshold to mask the interior
        of the brain. 5000 looks like a good choice. To check this,
        reset the colour limits as follows:
      </p>
      <xmp>
set( gca, 'CLim', [ 5000 15000 ] );
</xmp><a href="figs/petmin2.jpg"><img src="figs/tn_petmin2.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Now we are ready to read in all the data inside the mask. If
        there is a lot of data, as in this case,
        <code>SurfStatReadVol</code> uses memory mapping rather than
        loading all the data into
        memory:
      </p>
      <xmp>
[ Y, vol ] = SurfStatReadVol( filenames, mindata&gt;=5000 );

    Filename: 'C:\keith\fMRI\manou\cbf_non_kin\SurfStat\tp7e6b2b61_2069_4960_a922_0fac58f6eacc'
    Writable: true
      Offset: 0
      Format: {'single' [498412 69] 'Data'}
      Repeat: Inf
        Data: 1x1 struct array with fields:
             Data
</xmp>If you had your own mask (1=in, 0=out) in 'mymaskfile', you must
      read it in as a volume with <code>SurfStatReadVol1</code>,
      extract the data part, then convert to a logical:
      <xmp>
mask = SurfStatReadVol1( 'mymaskfile' );
[ Y, vol ] = SurfStatReadVol( filenames, logical(mask.data) );
</xmp>If you want to speed things up, you can read in every 2nd voxel,
      which doesn't
      need memory mapping, using:
      <xmp>
[ Y, vol ] = SurfStatReadVol( filenames, mindata&gt;=5000, 2 );
</xmp>This would allow you to quickly explore a variety of models.
      Proceeding with the full data, let's check the slice with <code>z=0</code>
      (0 in <code>layout</code>leaves a gap in the array for the
      deleted scan):
      <xmp>
layout = reshape( [1:24, 0, 25:69], 5, 14 );
clf; SurfStatViews( Y, vol, 0, layout );
</xmp><a href="figs/pet2.jpg"><img src="figs/tn_pet2.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        It is immediately obvious that the data need normalizing so that
        all images have roughly the same average intensity, as follows:
      </p>
      <xmp>
Y = SurfStatNorm( Y, [], 'divide');
clf; SurfStatViews( Y, vol, 0, layout );
</xmp><a href="figs/petnorm.jpg"><img src="figs/tn_petnorm.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Since the design is almost balanced, the simplest way for
        generating
        the levels of the factors for subject and condition is to
        generate them for a balanced design, then delete the levels for
        the bad scan:
      </p>
      <xmp>
subj = gl( 'Subj', 14, 5, 70);
subj = subj( [1:24, 26:70] )

    'Subj1'
    'Subj1'
    'Subj1'
    'Subj1'
    'Subj1'
    'Subj2'
    'Subj2'
    ...
    'Subj13'
    'Subj13'
    'Subj14'
    'Subj14'
    'Subj14'
    'Subj14'
    'Subj14'

cond = gl( {'h1','h2','h3','h4','hb'} ,1, 70 );
cond = cond( [1:24, 26:70] )

    'h1'
    'h2'
    'h3'
    'h4'
    'hb'
    'h1'
    'h2'
    ...
    'h4'
    'hb'
    'h1'
    'h2'
    'h3'
    'h4'
    'hb'
</xmp>Let's look at a model with condition as a fixed effect and subject
      as a random effect:
      <xmp>
Cond = term( cond );
Subj = term( subj );
M = 1 + Cond + random( Subj ) + I;
image( M );
</xmp><a href="figs/petmod.jpg"><img src="figs/tn_petmod.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Fitting the model, the within-subject correlation is quite high,
        averaging 0.59:
      </p>
      <xmp>
slm = SurfStatLinMod( Y, M, vol );
clf; SurfStatView1( slm.r, vol );
title('Within-subject correlation')
mean( slm.r )
    0.5892
</xmp><a href="figs/petcor.jpg"><img src="figs/tn_petcor.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Now we test for the difference between the 3Hz condition and the
        baseline, picking two slices at <code>z=[-20, 60]</code> for
        display:
      </p>
      <xmp>
slm = SurfStatT( slm, Cond.h3 - Cond.hb );
clf; SurfStatView1( slm.t, vol, 'z', [-20 60] );
title('T-statistic for 3Hz - baseline');
</xmp><a href="figs/pett1.jpg"><img src="figs/tn_pett1.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        To get a better look, let's threshold the T-statistic at 3 and
        add it to the figure by leaving off the <code>clf</code>
        command (which clears the figure window):
      </p>
      <xmp>
SurfStatView1( slm.t, vol, 'datathresh', 3 );
title('T-statistic for 3Hz - baseline');
</xmp><a href="figs/pett2.jpg"><img src="figs/tn_pett2.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        We could add the mask to the image as well:
      </p>
      <xmp>
SurfStatView1( slm.t, vol, 'mask', 1 );
title('T-statistic for 3Hz - baseline');
</xmp><a href="figs/pett3.jpg"><img src="figs/tn_pett3.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        Other properties such as the colour and transparency can be
        modified, see the help of <code>SurfStatView1</code>, and
        strung together in pairs of arguments after <code>vol</code>.
        You may like the more traditional view of slices, say every
        10mm:
      </p>
      <xmp>
layout = reshape( [1:11 0], 3, 4);
clf; SurfStatViews( slm.t, vol, [-30:10:70], layout );
</xmp><a href="figs/pett4.jpg"><img src="figs/tn_pett4.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        Of course you may prefer to write out the T-statistic so you can
        load it into your own favourite viewer:
      </p>
      <xmp>
SurfStatWriteVol( 'c:/keith/surfstat/data/tstat.mnc', slm.t, vol );
</xmp>Now we come to the inference. Since the T-statistic comes from a
      linear mixed effects model, its effective degrees of freedom
      varies spatially, averaging at 51.2:
      <xmp>
clf; SurfStatView1( slm.dfs, vol );
mean( slm.dfs )
   51.1516
title('Degrees of freedom, mean = 51.2');
</xmp><a href="figs/petdf.jpg"><img src="figs/tn_petdf.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
        Note that the mean effective df is slightly higher than the
        fixed effects
        df, which would be 69 - 14 - 5 + 1 = 51. This is because the
        mixed effects model has recovered some of the between-subject
        variation to increase the amount of information about the
        contrast.
        Finally the P-values and Q-values are:
      </p>
      <xmp>
[ pval, peak, clus] = SurfStatP( slm );

term( clus )

  clusid  nverts  resels       P
------------------------------------------
   1      2137        13.1781  4.3378e-006
   2      1321        10.5468  4.7328e-006
   3       731        4.50147   0.00021312
   4       108       0.930881      0.18245
   5        62       0.658461      0.39604
...
term( peak ) + term( SurfStatInd2Coord( peak.vertid, vol )', {'x','y','z'})

  t       vertid  clusid  P            x       y       z
--------------------------------------------------------------------
  8.5028  454759   1      5.8716e-006  -34.84  -19.44           58.5
  7.5756  444601   1      0.000124403  -36.18  -17.72           55.5
  7.4453   64818   2      0.000189549   16.08  -53.84          -19.5
  7.3037  467879   1      0.000299923   -33.5  -26.32             63
  7.2892  463681   1      0.000313491  -34.84  -26.32           61.5
   6.461   72281   2        0.0044887    20.1  -55.56            -18
  6.3465   64638   2       0.00644978   21.44  -57.28          -19.5
  6.1895  475829   1        0.0106013  -28.14     -16             66
  5.9699  438053   1        0.0210979  -34.84  -38.36             54
  5.6383  445139   3        0.0587249   -4.02    -7.4           55.5
  5.4934  121064   2        0.0911926     6.7  -62.44             -9
...
clf; SurfStatView1( pval, vol );
title('P-value &lt; 0.05');
</xmp>The red blobs are local maxima with P&lt;0.05, and the three
      transparent blue blobs are
      the three clusters with extents that have P&lt;0.05:
      <p>
        <a href="figs/petp.jpg"><img src="figs/tn_petp.jpg" alt="[Click
            to enlarge image]" border="0"></a></p>
      <p>
      </p>
      <xmp>
clf; SurfStatView1( SurfStatQ( slm ), vol );
title('Q-value &lt; 0.05');
</xmp><a href="figs/petq.jpg"><img src="figs/tn_petq.jpg" alt="[Click to
          enlarge image]" border="0"></a>
      <p>
        Finally, just for amusement, let's add a surface to the last
        image:
      </p>
      <xmp>
avsurf = SurfStatReadSurf( 'c:/keith/fmri/icbm/av.obj' );
load c:/keith/surfstat/data/meanthick
SurfStatView1( meanthick, avsurf );
</xmp><a href="figs/petqs.jpg"><img src="figs/tn_petqs.jpg" alt="[Click
          to enlarge image]" border="0"></a>
      <p>
      </p>
      <hr>
      <a name="pet2"></a>
      <h3>PET data: more elaborate linear models</h3>
      In the above analysis, we only compared the scan at 3Hz with
      baseline. We might be interested in a linear effect of frequency.
      Since we are exploring the data, it is better to read in every
      second voxel, which avoids memory mapping and speeds up our
      analysis:
      <xmp>
[ Y, vol ] = SurfStatReadVol( filenames, mindata&gt;=5000, 2 );
</xmp>There are two ways of doing this, as discussed in a <a
        href="http://www.math.mcgill.ca/keith/fmristat/#linear">similar
        analysis of fMRI data</a>. The first is to simply look at a
      linear contrast in the four frequencies, as follows:
      <xmp>
slm = SurfStatLinMod( Y, M, vol );
slm = SurfStatT( slm, -3*Cond.h1 - Cond.h2 + Cond.h3 + 3*Cond.h4 );
mean( slm.dfs )
   51.0016
clf; SurfStatView1( slm.t, vol, 'z', [-20 60] );
title('T-statistic for a linear contrast in Hz, 51.0 df');
</xmp><a href="figs/petlint.jpg"><img src="figs/tn_petlint.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        An alternative is to make up a new linear model with an explicit
        linear variable for frequency. To do this, we extract the
        frequencies from the <code>cond</code> variable, and set the
        baseline to 0:
      </p>
      <xmp>
hz = fac2var( cond );
hz( hz==5 ) = 0;
Hz = term( hz )

  hz
----
  1
  2
  3
  4
  0
  1
  2
  3
  4
  0
  1
  2
  ...
</xmp>This will be our frequency variable. Now we create a factor for
      the baseline, so that we can "model out" the baseline scan by
      giving it a separate coefficient:
      <xmp>
Baseline = term( var2fac( hz==0, {'h1234', 'hb'} ) )

  h1234  hb
-----------
  1      0
  1      0
  1      0
  1      0
  0      1
  1      0
  1      0
  1      0
  1      0
  0      1
  1      0
  1      0
  ...
</xmp>The linear model with <code>Baseline + Hz</code> does not force
      the intercept of the Hz effect to go through the baseline data,
      since <code>Hz=0</code> might not produce the same response as
      the baseline. In other words, the intercept of the Hz effect is
      modeled separately from the baseline:
      <xmp>
M1 = Baseline + Hz + random( Subj ) + I;
clf; image( M1 );
</xmp><a href="figs/petlinM1.jpg"><img src="figs/tn_petlinM1.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Now we fit the model in the usual way:
      </p>
      <xmp>
slm1 = SurfStatLinMod( Y, M1, vol );
slm1 = SurfStatT( slm1, hz );
mean(slm1.dfs)
   53.0016
clf; SurfStatView1( slm1.t, vol, 'z', [-20 60] );
title('T-statistic for a linear effect in Hz, 53.0 df');
</xmp><a href="figs/petlinT1.jpg"><img src="figs/tn_petlinT1.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        As we can see, the two T-statistics, the first a linear
        contrast, the second a linear effect of Hz, are almost
        identical. The main difference is that the df of the first is
        lower (51) than the second (53). Why? The reason is that the
        first model has a <i>separate</i> effect for each level of Hz,
        in other words, it allows for an arbitrary non-linear effect of
        Hz; the second only has a linear effect of Hz, so it has ~2 more
        df for the error. Which is better? As usual, it's a trade-off;
        the first will have an sd that is less biased, but less
        accurate; the second will have an sd that might be biased (if
        the the true Hz effect is non-linear, e.g. quadratic) but more
        accurate. Luckily both methods give almost identical results.
        Here are the P-values for the second method:
      </p>
      <xmp>
[ pval, peak, clus ] = SurfStatP( slm1 );

term( clus )
  clusid  nverts  resels     P
----------------------------------------
   1      185        7.3794  8.7721e-006
   2      106        1.5688     0.027234
   3       39        1.3454     0.047272
   4       46        1.3417     0.047724
   5       25        1.3279     0.049443
   6       19        1.0097      0.11653
   7       18       0.75241      0.24668
...

term( peak ) + term( SurfStatInd2Coord( peak.vertid, vol )', {'x','y','z'})
  t       vertid  clusid  P           x       y       z
-----------------------------------------------------------
  6.0356  14055   38      0.00497395  -69.68  -46.96  -10.5
  5.9801  27761    2      0.00609785  -61.64   21.84    7.5
  5.4596  56971    1       0.0404088   -40.2  -19.44   58.5
  5.4004  58126    1       0.0499989  -37.52  -19.44   61.5
  5.3777  21434    6       0.0541458    26.8   14.96   -1.5
  5.1428  55731    1        0.125335  -42.88     -16   55.5
...

figure(2); clf; SurfStatView1( pval, vol );
title('P-value &lt; 0.05');
</xmp><a href="figs/petlinp1.jpg"><img src="figs/tn_petlinp1.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        The activated local maxima are almost too small to see. Let's
        plot the data at the maximum T-statistic:
      </p>
      <xmp>
clf; SurfStatPlot( hz, Y( :, 14055 ), M1 );
ylim([0.3 0.9]);
</xmp><a href="figs/petlinplotT1.jpg"><img
          src="figs/tn_petlinplotT1.jpg" alt="[Click to enlarge image]"
          border="0"></a>
      <p>
        Although the T-statistic is high (6.04), the data doesn't seem
        to be highly correlated. This is because the Y values are
        adjusted only for the fixed effects, not the fixed and random
        (subject) effects. One way to adjust Y for subject is to treat
        subject as fixed:
      </p>
      <xmp>
MFixed = Baseline + Subj + I;
clf; SurfStatPlot( hz, Y( :, 14055 ), MFixed );
ylim([0.3 0.9]);
</xmp><a href="figs/petlinplotTF.jpg"><img
          src="figs/tn_petlinplotTF.jpg" alt="[Click to enlarge image]"
          border="0"></a>
      <p>
        The command <code>ylim</code> sets the same y limits, so we can
        compare the plots.
        The slopes are almost identical, but now the data in the second
        plot are far less variable because the subject effect has been
        removed, so now the data looks more correlated.</p>
      <p>
        Let's look at a quadratic effect of Hz. Again there are two ways
        of doing it, either through contrasts or through an explicit
        quadratic model. Here's the first approach, through a quadratic
        contrast:
      </p>
      <xmp>
slm = SurfStatT( slm, Cond.h1 - Cond.h2 - Cond.h3 + Cond.h4 );
mean( slm.dfs )
   51.0016
clf; SurfStatView1( slm.t, vol, 'z', [-20 60] );
title('T-statistic for a quadratic contrast in Hz, 51.0 df');
</xmp><a href="figs/petlinquadt.jpg"><img src="figs/tn_petlinquadt.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Here's the model for the second approach, though a quadratic
        model:
      </p>
      <xmp>
M2 = Baseline + Hz + Hz^2 + random( Subj ) + I;
clf; image( M2 );
</xmp><a href="figs/petlinM2.jpg"><img src="figs/tn_petlinM2.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        Here's the analysis of the quadratic effect:
      </p>
      <xmp>
slm2 = SurfStatLinMod( Y, M2, vol );
slm2 = SurfStatT( slm2, hz.^2 );
mean(slm2.dfs)
   52.0016
clf; SurfStatView1( slm2.t, vol, 'z', [-20 60] );
title('T-statistic for an effect of Hz^2, 52.0 df');
</xmp><a href="figs/petlinM2T.jpg"><img src="figs/tn_petlinM2T.jpg"
          alt="[Click to enlarge image]" border="0"></a>
      <p>
        The analyses are almost identical, apart from the different df,
        an neither shows any significant quadratic effect.</p>
      <p>
        Finally, let's look at a cubic effect of Hz, done both ways:
      </p>
      <xmp>
slm = SurfStatT( slm, -Cond.h1 + 3*Cond.h2 - 3*Cond.h3 + Cond.h4 );
mean( slm.dfs )
   51.0016

M3 = Baseline + Hz + Hz^2 + Hz^3 + random( Subj ) + I;
slm3 = SurfStatT( SurfStatLinMod( Y, M3, vol ), hz.^3 );
mean(slm3.dfs)
   51.0016
</xmp>Why are the mean dfs the same? In fact the fits of the models, <code>slm.SSE</code>'s,
      are the same as well. The answer is that they are exactly the same
      model! A cubic model in Hz (<code>M3</code>) is identical to a
      separate mean for each of the four levels of Hz (<code>M</code>).
      The only difference is that the models are parameterized in
      different ways. But the fitted models are identical. Why? A cubic
      can be fitted exactly to any data at four points.
      <hr>
      <a name="future"></a>
      <h3>Future features</h3>
    </li>
    <li> Support for Gifti file format.
    </li>
    <li> F tests for mixed effects models.
    </li>
    <li> Multivariate mixed effects models.
    </li>
    <li> About time to upgrade
      <a href="http://www.math.mcgill.ca/keith/fmristat/">
        FmriStat</a> ...
    </li>
    <li> I would really appreciate any feed-back!
      <hr>
      <a name="references"></a>
      <h3>References for random field theory</h3>
    </li>
    <li> Adler, R.J. and Taylor, J.E. (2007). <i>Random fields and
        geometry</i>. Springer.
      <p>
      </p>
    </li>
    <li> Adler, R.J., Taylor, J.E. and Worsley, K.J. (2008). <a
        href="http://iew3.technion.ac.il/~radler/hrf.pdf"><i>Random
          fields, geometry, and their applications</i></a>. In
      preparation.
      <p>
      </p>
    </li>
    <li> Hagler, D.J., Saygin, A.P. and Sereno, M.I. (2006). Smoothing
      and cluster thresholding for cortical surface-based group analysis
      of fMRI data. <i>NeuroImage,</i> <b>33</b>:1093-1103.
      <p>
      </p>
    </li>
    <li> Hayasaka, S., Phan, K.L., Liberzon, I., Worsley, K.J. and
      Nichols, T.E. (2004). Non-Stationary cluster
      size inference with random field and permutation methods. <i>NeuroImage,</i>
      <b>22</b>:676-687.
      <p>
      </p>
    </li>
    <li>Taylor, J.E. and Adler, R.J. (2003), Euler characteristics for
      Gaussian fields on manifolds. <i>Annals of Probability,</i> <b>31</b>:533-563.
      <p>
      </p>
    </li>
    <li>Taylor, J.E. and Worsley, K.J. (2007).
      <a href="http://www.math.mcgill.ca/keith/noniso/noniso.htm">Detecting
        sparse signal in random fields, with
        an application to brain mapping. </a>
      <i>Journal of the American Statistical Association</i>, <b>102</b>:913-928.
      <p>
      </p>
    </li>
    <li>Worsley, K.J., Andermann, M., Koulis,
      T., MacDonald, D., and Evans, A.C. (1999).
      <a href="http://www.math.mcgill.ca/keith/bm98/bm98.abstract.html">
        Detecting changes in non-isotropic images. </a>
      <i>Human Brain Mapping</i>, <b>8</b>:98-101.
      <p>
      </p>
    </li>
  </body>
</html>
